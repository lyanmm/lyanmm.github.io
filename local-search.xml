<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue.js官网见闻</title>
    <link href="/2020/07/26/Vue%E5%AE%98%E7%BD%91%E8%A7%81%E9%97%BB/"/>
    <url>/2020/07/26/Vue%E5%AE%98%E7%BD%91%E8%A7%81%E9%97%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-js官网见闻"><a href="#Vue-js官网见闻" class="headerlink" title="Vue.js官网见闻"></a>Vue.js官网见闻</h1><p>其实没有在开头写感想的习惯，但这篇我就是要写下来警醒自己，记下朋友的一句话：“等你基础好了点，会觉得当年过不了是活该，这都不懂。”</p><p>这一篇会持续每天更新一点。</p><h2 id="一、起步"><a href="#一、起步" class="headerlink" title="一、起步"></a>一、起步</h2>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Axios简单配置使用</title>
    <link href="/2020/07/24/Axios%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/07/24/Axios%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios简单配置使用"><a href="#Axios简单配置使用" class="headerlink" title="Axios简单配置使用"></a>Axios简单配置使用</h1><h2 id="一、请求方法"><a href="#一、请求方法" class="headerlink" title="一、请求方法"></a>一、请求方法</h2><p>返回一个Promise</p><ul><li><p>单次请求：</p><p>axios.request(config)</p><p>axios.get(url[, config])</p><p>axios.delete(url[, config])</p><p>axios.head(url[, config])</p><p>axios.post(url[, data[, config]])</p><p>axios.put(url[, data[, config]])</p><p>axios.patch(url[, data[, config]])</p></li><li><p>并发请求：</p><p>axios.all(iterable)</p><p>axios.spread(callback)</p></li></ul><h2 id="二、创建实例"><a href="#二、创建实例" class="headerlink" title="二、创建实例"></a>二、创建实例</h2><p>创建实例，会继承axios上的请求方法，并且可以自定义一些共有配置</p><p>axios.create(config);</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> instance = axios.create(&#123;  baseURL: <span class="hljs-string">'https://some-domain.com/api/'</span>,  timeout: <span class="hljs-number">1000</span>,  headers: &#123;<span class="hljs-string">'X-Custom-Header'</span>: <span class="hljs-string">'foobar'</span>&#125;&#125;);</code></pre><h2 id="三、默认配置"><a href="#三、默认配置" class="headerlink" title="三、默认配置"></a>三、默认配置</h2><p>将被用在各个请求的配置默认值。</p><ol><li><p>全局：</p><pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">'https://api.example.com'</span>;</code></pre></li><li><p>自定义实例：</p><pre><code class="hljs js"><span class="hljs-comment">// 创建实例时设置配置的默认值</span><span class="hljs-keyword">var</span> instance = axios.create(&#123;  baseURL: <span class="hljs-string">'https://api.example.com'</span>&#125;);<span class="hljs-comment">// 在实例已创建后修改默认值</span>instance.defaults.headers.common[<span class="hljs-string">'Authorization'</span>] = AUTH_TOKEN;</code></pre></li><li><p>优先级：</p><p>config&gt;instance&gt;axios</p><pre><code class="hljs js"><span class="hljs-comment">// 使用由库提供的配置的默认值来创建实例</span><span class="hljs-comment">// 此时超时配置的默认值是 `0`</span><span class="hljs-keyword">var</span> instance = axios.create();<span class="hljs-comment">// 覆写库的超时默认值</span><span class="hljs-comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span>instance.defaults.timeout = <span class="hljs-number">2500</span>;<span class="hljs-comment">// 为已知需要花费很长时间的请求覆写超时设置</span>instance.get(<span class="hljs-string">'/longRequest'</span>, &#123;  timeout: <span class="hljs-number">5000</span>&#125;);</code></pre></li></ol><h2 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h2><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><ul><li><p>添加拦截器：</p><pre><code class="hljs js"><span class="hljs-comment">// 添加请求拦截器</span>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;    <span class="hljs-comment">// 在发送请求之前做些什么</span>    <span class="hljs-keyword">return</span> config;    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-comment">// 对请求错误做些什么</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);    &#125;);<span class="hljs-comment">// 添加响应拦截器</span>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-comment">// 对响应数据做点什么</span>    <span class="hljs-keyword">return</span> response;    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-comment">// 对响应错误做点什么</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);    &#125;);<span class="hljs-comment">// 为实例添加拦截器</span><span class="hljs-keyword">var</span> instance = axios.create();instance.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*...*/</span>&#125;);</code></pre></li><li><p>取消拦截器：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*...*/</span>&#125;);axios.interceptors.request.eject(myInterceptor);</code></pre></li></ul><h2 id="五、自定义错误范围"><a href="#五、自定义错误范围" class="headerlink" title="五、自定义错误范围"></a>五、自定义错误范围</h2><p>设定 validateStatus 属性可以自定义会处理的响应状态码的范围</p><pre><code class="hljs js">axios.get(<span class="hljs-string">'/user/12345'</span>, &#123;  validateStatus: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;    <span class="hljs-keyword">return</span> status &lt; <span class="hljs-number">500</span>; <span class="hljs-comment">// 状态码在大于或等于500时才会 reject</span>  &#125;&#125;)</code></pre><h2 id="六、取消请求"><a href="#六、取消请求" class="headerlink" title="六、取消请求"></a>六、取消请求</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">var</span> cancel;axios.get(<span class="hljs-string">'/user/12345'</span>, &#123;  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>&#123;    <span class="hljs-comment">// executor 函数接收一个 cancel 函数作为参数</span>    cancel = c;  &#125;)&#125;);<span class="hljs-comment">// 取消请求</span>cancel();</code></pre><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p><a href="https://juejin.im/post/5b27682f6fb9a00e733f121e" target="_blank" rel="noopener">https://juejin.im/post/5b27682f6fb9a00e733f121e</a></p><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组等常用方法整理</title>
    <link href="/2020/07/23/%E6%95%B0%E7%BB%84%E7%AD%89%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <url>/2020/07/23/%E6%95%B0%E7%BB%84%E7%AD%89%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1、splice"><a href="#1、splice" class="headerlink" title="1、splice()"></a>1、splice()</h2><ol><li><p>定义：</p><p>通过<u>删除</u>或<u>替换</u>现有元素或者<u>原地添加</u>新的元素来修改原数组。由被删除的元素组成的一个数组。</p></li><li><p>语法：</p><pre><code class="hljs js">array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> myFish = [<span class="hljs-string">"angel"</span>, <span class="hljs-string">"clown"</span>, <span class="hljs-string">"mandarin"</span>, <span class="hljs-string">"sturgeon"</span>];<span class="hljs-keyword">var</span> removed = myFish.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"drum"</span>);<span class="hljs-comment">// 运算后的 myFish: ["angel", "clown", "drum", "mandarin", "sturgeon"]</span><span class="hljs-comment">// 被删除的元素: [], 没有元素被删除</span><span class="hljs-keyword">var</span> myFish = [<span class="hljs-string">'angel'</span>, <span class="hljs-string">'clown'</span>, <span class="hljs-string">'drum'</span>, <span class="hljs-string">'mandarin'</span>, <span class="hljs-string">'sturgeon'</span>];<span class="hljs-keyword">var</span> removed = myFish.splice(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// 运算后的 myFish: ["angel", "clown", "drum", "sturgeon"]</span><span class="hljs-comment">// 被删除的元素: ["mandarin"]</span></code></pre></li><li><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice</a></p></li></ol><h2 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice()"></a>2、slice()</h2><ol><li><p>定义：返回一个新数组，由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</p></li><li><p>语法：</p><pre><code class="hljs js">arr.slice([begin[, end]])</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">'Banana'</span>, <span class="hljs-string">'Orange'</span>, <span class="hljs-string">'Lemon'</span>, <span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Mango'</span>];<span class="hljs-keyword">var</span> citrus = fruits.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">// citrus contains ['Orange','Lemon']</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">list</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);&#125;<span class="hljs-keyword">var</span> list1 = list(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><span class="hljs-comment">// 将一个类数组对象/集合转换成一个新数组。</span></code></pre></li></ol><h2 id="3、indexOf"><a href="#3、indexOf" class="headerlink" title="3、indexOf()"></a>3、indexOf()</h2><ol><li><p>定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p></li><li><p>语法：</p><pre><code class="hljs js">arr.indexOf(searchElement[, fromIndex])</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-comment">// 数组去重</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr)) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'type error!'</span>)    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-keyword">var</span> array = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-keyword">if</span> (array.indexOf(arr[i]) === <span class="hljs-number">-1</span>) &#123;      array.push(arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;</code></pre></li></ol><h2 id="4、entries-，keys-和-values"><a href="#4、entries-，keys-和-values" class="headerlink" title="4、entries()，keys() 和 values()"></a>4、entries()，keys() 和 values()</h2><ol><li><p>定义：遍历数组，返回一个遍历器对象，可以用for…of循环进行遍历。keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p></li><li><p>语法：</p><pre><code class="hljs isbl"><span class="hljs-variable">arr.entries</span>()/<span class="hljs-function"><span class="hljs-title">keys</span>()/<span class="hljs-title">values</span>()</span></code></pre></li><li><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].keys()) &#123;  <span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].values()) &#123;  <span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// 'a'</span><span class="hljs-comment">// 'b'</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>].entries()) &#123;  <span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 "a"</span><span class="hljs-comment">// 1 "b"</span><span class="hljs-comment">// 使用遍历器对象上的next()</span><span class="hljs-keyword">let</span> letter = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];<span class="hljs-keyword">let</span> entries = letter.entries();<span class="hljs-built_in">console</span>.log(entries.next().value); <span class="hljs-comment">// [0, 'a']</span><span class="hljs-built_in">console</span>.log(entries.next().value); <span class="hljs-comment">// [1, 'b']</span><span class="hljs-built_in">console</span>.log(entries.next().value); <span class="hljs-comment">// [2, 'c']</span></code></pre></li></ol><h2 id="5、flat"><a href="#5、flat" class="headerlink" title="5、flat()"></a>5、flat()</h2><ol><li><p>定义：按照一个可指定的深度（默认为1）递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p></li><li><p>语法：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> newArray = arr.flat([depth])</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">1</span>, ,<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];arr2.flat();<span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];arr3.flat(<span class="hljs-number">2</span>);<span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><span class="hljs-comment">//使用 Infinity，可展开任意深度的嵌套数组</span><span class="hljs-keyword">var</span> arr4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]]]];arr4.flat(<span class="hljs-literal">Infinity</span>);<span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></code></pre></li></ol><h1 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h1><h2 id="1、finally"><a href="#1、finally" class="headerlink" title="1、finally()"></a>1、finally()</h2><ol><li><p>定义：不管 Promise 对象最后状态如何，都会执行的操作，即该操作应该是与状态无关的，不依赖于 Promise 的执行结果。</p></li><li><p>语法：</p><pre><code class="hljs js">promise.finally(fn)</code></pre></li><li><p>示例：</p><pre><code class="hljs js">promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;).finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;···&#125;);</code></pre></li></ol><h2 id="2、Promise-all"><a href="#2、Promise-all" class="headerlink" title="2、Promise.all()"></a>2、Promise.all()</h2><ol><li><p>定义：将多个 Promise 实例，包装成一个新的 Promise 实例。当这些实例均为fulfilled时，封装后的实例是fulfilled，其余情况为rejected。</p></li><li><p>语法：传入的参数必须有必须具有 Iterator 接口，数组等。</p><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all([Iterator]);</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="hljs-string">'hello'</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'报错了'</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<span class="hljs-built_in">Promise</span>.all([p1, p2]).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result)).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));<span class="hljs-comment">// ["hello", Error: 报错了]</span><span class="hljs-comment">// 如果作为参数的 Promise 实例，自己定义了catch方法，</span><span class="hljs-comment">// 那么它一旦被rejected，并不会触发Promise.all()的catch方法。</span></code></pre></li></ol><h2 id="3、Promise-race"><a href="#3、Promise-race" class="headerlink" title="3、Promise.race()"></a>3、Promise.race()</h2><ol><li><p>定义：将多个 Promise 实例，包装成一个新的 Promise 实例。当这些实例内有一个状态发生改变时，那个率先改变的 Promise 实例的返回值，就传递给封装后实例调用。</p></li><li><p>语法：</p><pre><code class="hljs css"><span class="hljs-selector-tag">Promise</span><span class="hljs-selector-class">.race</span>(<span class="hljs-selector-attr">[Iterator]</span>)</code></pre></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([  fetch(<span class="hljs-string">'/resource-that-may-take-a-while'</span>),  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'request timeout'</span>)), <span class="hljs-number">5000</span>)  &#125;)]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);<span class="hljs-comment">// 如果 5 秒之内fetch方法无法返回结果，</span><span class="hljs-comment">// 变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配</title>
    <link href="/2020/07/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <url>/2020/07/20/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="一、常用单位"><a href="#一、常用单位" class="headerlink" title="一、常用单位"></a>一、常用单位</h2><ul><li>rem：基于 html 节点的字体大小，浏览器一般默认字体大小为 16px，即 1rem=16px。</li><li>em：基于当前区域内的字体大小，字体大小可从父级继承，也可在子级设定，若父级字体大小12px，则1em=12px。</li><li>vh：viewportHeight，视窗高度，该单位会把视窗宽度划分100份，如果宽为1334px，则1vh=13.34px。</li><li>vw：viewportWidth，其余同vw。</li></ul><h2 id="二、meta标签"><a href="#二、meta标签" class="headerlink" title="二、meta标签"></a>二、meta标签</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"</span>&gt;</span></code></pre><img src="https://i.loli.net/2020/07/26/zR9KFNrdMqxlXQD.png" srcset="/img/loading.gif" alt="image-20200726104338071" style="zoom:80%;" /><p>viewport-fit：部分机型底部存在底部指示条，指示条的操作区域与页面底部存在重合，容易导致用户误操作，因此我们需要针对这些机型进行底部安全区适配。</p><h2 id="三、媒体查询实现响应式布局"><a href="#三、媒体查询实现响应式布局" class="headerlink" title="三、媒体查询实现响应式布局"></a>三、媒体查询实现响应式布局</h2><p>媒体查询：</p><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">960px</span>)&#123;    <span class="hljs-selector-tag">body</span>&#123;      <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#FF6699</span>    &#125;&#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">768px</span>)&#123;    <span class="hljs-selector-tag">body</span>&#123;      <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#00FF66</span>;    &#125;&#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">550px</span>)&#123;    <span class="hljs-selector-tag">body</span>&#123;      <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#6633FF</span>;    &#125;&#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">320px</span>)&#123;    <span class="hljs-selector-tag">body</span>&#123;      <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#FFFF00</span>;    &#125;&#125;</code></pre><p>给不同的屏幕宽度设置不同的样式，用flex、rem作辅助，并且规定好不同尺寸下要展示、隐藏的部分，实现起来非常的麻烦。</p><p>做响应式布局的库有Bootstrap。</p><p>因为rem是基于html标签下的字体大小，可以根据浏览器窗口大小用JS代码调整，存在一定的耦合。</p><p>rem兼容性好。</p><h2 id="四、自适应布局"><a href="#四、自适应布局" class="headerlink" title="四、自适应布局"></a>四、自适应布局</h2><p>主要作用同种终端下差别不太大的页面大小，一般都分别为PC和移动两端作各自的页面开发。</p><p>一般采用vh/vw单位，即使是用rem也是设置好根元素字体大小好，将视窗宽度划分为100份，模拟vh/vw的效果。</p><p>注意使用vh/vw开发的时候可能会出现无法整除的情况，可以辅以一些媒体查询来做好适配。</p><p>具体方法：</p><ol><li><p>安装：</p><pre><code class="hljs shell">npm install postcss-px-to-viewport</code></pre></li><li><p>使用：</p><pre><code class="hljs js"><span class="hljs-comment">// Vue项目使用，新建postcss.config.js</span>plugins:&#123;    <span class="hljs-string">"autoprefixer"</span>:&#123;      browsers: [<span class="hljs-string">'last 5 versions'</span>]    &#125;,    <span class="hljs-string">"postcss-px-to-viewport"</span>:&#123;      <span class="hljs-comment">// 设计稿大小为iPhone5的大小</span>      viewportWidth: <span class="hljs-number">320</span>,<span class="hljs-comment">//视窗宽度，对应设计稿宽度</span>      viewportHeight: <span class="hljs-number">568</span>,<span class="hljs-comment">//视窗高度，对应设计稿高度</span>      unitPrecision: <span class="hljs-number">5</span>,<span class="hljs-comment">//指定`px`转换为视窗单位值的小数位数</span>      viewportUnit: <span class="hljs-string">'vw'</span>,<span class="hljs-comment">//指定需要转换成的视窗单位</span>      <span class="hljs-comment">// selectorBlackList: [],//指定不需要转换的类</span>      minPixelValue: <span class="hljs-number">1</span>,<span class="hljs-comment">//小于或等于`1px`不转换为视窗单位</span>      mediaQuery: <span class="hljs-literal">false</span>,<span class="hljs-comment">//允许在媒体查询中转换`px`</span>    &#125;  &#125;<span class="hljs-comment">// Webpack</span>&#123;  loader: <span class="hljs-string">'postcss-loader'</span>,    options: &#123;    plugins: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [      <span class="hljs-built_in">require</span>(<span class="hljs-string">'autoprefixer'</span>)(&#123;        browsers: [<span class="hljs-string">'last 5 versions'</span>]      &#125;),      <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-px-to-viewport'</span>)(&#123;        viewportWidth: <span class="hljs-number">375</span>, <span class="hljs-comment">//视口宽度（数字)</span>        viewportHeight: <span class="hljs-number">1334</span>, <span class="hljs-comment">//视口高度（数字）</span>        unitPrecision: <span class="hljs-number">3</span>, <span class="hljs-comment">//设置的保留小数位数（数字）</span>        viewportUnit: <span class="hljs-string">'vw'</span>, <span class="hljs-comment">//设置要转换的单位（字符串）</span>        selectorBlackList: [], <span class="hljs-comment">//不需要进行转换的类名（数组）</span>        minPixelValue: <span class="hljs-number">1</span>, <span class="hljs-comment">//设置要替换的最小像素值（数字）</span>        mediaQuery: <span class="hljs-literal">false</span> <span class="hljs-comment">//允许在媒体查询中转换px（true/false）</span>      &#125;)    ]  &#125;</code></pre></li></ol><h2 id="五、预处理器函数转换单位"><a href="#五、预处理器函数转换单位" class="headerlink" title="五、预处理器函数转换单位"></a>五、预处理器函数转换单位</h2><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> pxtorem(<span class="hljs-variable">$px</span>)&#123;  <span class="hljs-comment">//$px为需要转换的字号</span>    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$px</span> / <span class="hljs-number">40px</span> * <span class="hljs-number">1rem</span>; <span class="hljs-comment">//40px为根字体大小</span>&#125;<span class="hljs-keyword">@function</span> pxtovw(<span class="hljs-variable">$px</span>)&#123;  <span class="hljs-comment">//$px为需要转换的字号</span>    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$px</span> * (<span class="hljs-number">100</span>/<span class="hljs-number">375</span>) * <span class="hljs-number">1vw</span>;  <span class="hljs-comment">// 375为视口宽度</span>&#125;</code></pre><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://juejin.im/post/5e6121c8e51d4526dc7be724" target="_blank" rel="noopener">https://juejin.im/post/5e6121c8e51d4526dc7be724</a></p><p><a href="https://juejin.im/post/5df59139518825123e7af459" target="_blank" rel="noopener">https://juejin.im/post/5df59139518825123e7af459</a></p><p><a href="https://juejin.im/post/5b5c7e1cf265da0f9f4e7381" target="_blank" rel="noopener">https://juejin.im/post/5b5c7e1cf265da0f9f4e7381</a></p><p><a href="https://juejin.im/post/5cddf289f265da038f77696c" target="_blank" rel="noopener">https://juejin.im/post/5cddf289f265da038f77696c</a></p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存</title>
    <link href="/2020/07/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <url>/2020/07/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><h2 id="一、缓存类型"><a href="#一、缓存类型" class="headerlink" title="一、缓存类型"></a>一、缓存类型</h2><p>两种缓存策略：强缓存 和 协商缓存。</p><ol><li>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。</li><li>当强缓存没有命中，浏览器发送一个请求到服务器，服务器判断这个资源是否命中协商缓存，如果协商缓存命中，服务器将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就从缓存中加载这个资源；</li><li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</li></ol><p>共同点：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；</p><p>区别：强缓存不会发请求，协商缓存会发请求。</p><h2 id="二、强缓存"><a href="#二、强缓存" class="headerlink" title="二、强缓存"></a>二、强缓存</h2><p>当浏览器对某资源的请求命中强缓存时，返回的HTTP状态为200，在控制台的network里的 size会显示为from cache。</p><p>强缓存实现方式：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>注意区分浏览器 加载资源时的请求 和 真正发送到服务器的请求 。</p><p>这两个http response header都用来表示资源在客户端缓存的有效期。Cache-Control优先级高于Expires，仅作为兼容性处理使用后者。</p><p>memory cache代表使用内存中的缓存，disk cache代表使用硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p><p><img src="https://i.loli.net/2020/07/20/oXO2mR9Vp5yDzS6.png" srcset="/img/loading.gif" alt="image-20200720120602458" style="zoom:67%;" /><img src="https://i.loli.net/2020/07/20/BT6VZLP5DNofkFn.png" srcset="/img/loading.gif" alt="image-20200720123958430"></p><h3 id="1、Expires"><a href="#1、Expires" class="headerlink" title="1、Expires"></a>1、Expires</h3><ol><li><p>概念：</p><p>HTTP 1.0提出的表示资源过期时间的header，是一个绝对时间，由服务器返回，用GMT格式的字符串表示。</p></li><li><p>原理：</p><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires；</li><li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li><li>浏览器再加载这个资源时，先从缓存中找，找到后拿出它的Expires跟当前的请求时间比较，如果没过期就能命中缓存，否则就不行（所以缓存命中的请求，返回的header并不是来自服务器，而是来自之前缓存的header）；</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</li></ol></li></ol><h3 id="2、Cache-Control"><a href="#2、Cache-Control" class="headerlink" title="2、Cache-Control"></a>2、Cache-Control</h3><ol><li><p>概念：</p><p>HTTP 1.1提出的表示资源过期时间的header，是一个相对时间，由服务器返回，以秒为单位，用数值表示。</p></li><li><p>原理：</p><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control；</li><li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li><li>浏览器再加载这个资源时，先从缓存中寻找，找到后根据它第一次请求时间和Cache-Control设定的时间，计算资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果没过期就能命中缓存，否则就不行；</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li></ol></li><li><p>补充：Cache-Control 还可以配合多种指令使用。</p><ul><li>private：表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。但 private 并不会使得缓存更加安全，它同样会传给中间服务器（如果安全性有要求，应该使用传输层安全措施），只是不缓存。</li><li>public：默认值，允许所有服务器缓存该资源。一般用于所有人都可以访问的资源（例如网站的 logo、图片、脚本等）。</li><li>其他参考MDN。</li></ul><img src="https://i.loli.net/2020/07/20/nAzlS6eTbNR8y9D.png" srcset="/img/loading.gif" alt="img" style="zoom: 80%;" /></li></ol><h2 id="三、协商缓存"><a href="#三、协商缓存" class="headerlink" title="三、协商缓存"></a>三、协商缓存</h2><p>强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，两种情况：</p><ul><li>协商缓存生效，返回304和 Not Modified。</li><li>协商缓存失效，返回200和请求结果。</li></ul><p>协商缓存实现方式：</p><ul><li>Last-Modified </li><li>ETag </li></ul><p>这个时候是真的发送请求到服务器，要占用网络资源。</p><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</p><h3 id="1、Last-Modified"><a href="#1、Last-Modified" class="headerlink" title="1、Last-Modified"></a>1、Last-Modified</h3><p>一般和其他首部配合使用，有 Last-Modified &amp; If-Modified-Since 和 Last-Modified &amp; If-Unmodified-Since，这里采用前者。</p><ol><li><p>概念：响应首部，其中包含资源做出修改的日期及时间。 通常用于判断接收到的或者存储的资源是否彼此一致。</p></li><li><p>原理：</p><ol><li><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Last-Modified，表示资源最后修改时间。</p></li><li><p>浏览器再次跟服务器请求这个资源时，在 request 的 header 加上If-Modified-Since，值是上一次请求时返回的 Last-Modified 的值。</p></li><li><p>如果浏览器收到 304 ，就从缓存中加载资源；</p><p>如果浏览器收到 200 ，就从服务器加载资源，并且 Last-Modified 在重新加载时会被更新，下次请求时，If-Modified-Since 就是上次返回的Last-Modified 的值。</p></li></ol></li><li><p>补充：</p><p>可能会出现服务器上资源有变化，但是最后修改时间没有变化的情况，精度低。</p></li></ol><h3 id="2、ETag"><a href="#2、ETag" class="headerlink" title="2、ETag"></a>2、ETag</h3><p>ETag &amp; If-None-Match</p><ol><li><p>概念：响应首部，资源的特定版本的标识符。如果给定URL中的资源内容更改，则一定要生成新的Etag值，跟最后修改时间无关。 </p></li><li><p>原理：</p><ol><li><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上 ETag，值是服务器根据当前请求的资源生成的一个唯一标识，是一个字符串。</p></li><li><p>浏览器再次跟服务器请求这个资源时，在request的header加上If-None-Match，值是上一次请求时返回的ETag的值。</p></li><li><p>服务器再次收到资源请求时，服务器只需要比较浏览器传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致。</p></li><li><p>一致则返回 304、Not Modified 和 跟If-None-Match值一样的ETag，浏览器从缓存中加载资源；</p><p>不同则返回 200 ，浏览器从服务器加载资源。</p></li></ol></li></ol><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</a></p><p><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57" target="_blank" rel="noopener">https://juejin.im/post/5b9346dcf265da0aac6fbe57</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag</a></p><img src="https://i.loli.net/2020/07/20/vDuQaRYmVcgp2nx.png" srcset="/img/loading.gif" alt="img" style="zoom: 67%;" />]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript运行机制</title>
    <link href="/2020/07/19/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/07/19/JavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript运行机制"><a href="#JavaScript运行机制" class="headerlink" title="JavaScript运行机制"></a>JavaScript运行机制</h1><h2 id="一、执行栈和任务队列"><a href="#一、执行栈和任务队列" class="headerlink" title="一、执行栈和任务队列"></a>一、执行栈和任务队列</h2><p><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener">https://juejin.im/post/5ba32171f265da0ab719a6d7</a></p><p>JS是单线程的，JS的任务还分为 同步任务 和 异步任务 。</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈。</li><li>主线程之外，还有一个任务队列。当异步任务有了运行结果，就在任务队列中放置一个事件。</li><li>当执行栈中所有同步任务执行完毕，系统就会读取任务队列，那些有运行结果的异步任务结束等待进入执行栈，开始执行。</li><li>只要主线程空了，就会去读取任务队列。</li></ol><p>执行栈和任务队列之间的事件循环机制会把任务队列里的任务不断推到执行栈中执行。</p><h2 id="二、宏任务和微任务"><a href="#二、宏任务和微任务" class="headerlink" title="二、宏任务和微任务"></a>二、宏任务和微任务</h2><p>异步任务又分为 宏任务 和 微任务 ，又各自有 宏任务队列 和 微任务队列。</p><ol><li>宏任务：宿主环境提供的叫宏任务，script 、setTimeout、setInterval 、setImmediate 、I/O 、UI rendering、new关键字（new Promise等）。</li><li>微任务：语言标准提供的叫微任务，MutationObserver、Promise.then()或catch()、Promise为基础开发的其它技术，比如fetch API、V8的垃圾回收过程、Node独有的process.nextTick。</li></ol><h2 id="三、事件循环"><a href="#三、事件循环" class="headerlink" title="三、事件循环"></a>三、事件循环</h2><p>Event loop 执行顺序：</p><ol><li>一开始整个脚本作为一个宏任务执行；</li><li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列；</li><li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完；</li><li>检查宏任务列表，有则依次执行；</li><li>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空。</li></ol><p>注意：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如setTimeout)将被放到下一轮宏任务中来执行。</p><h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><p>封装一个异步加载图片的方法</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImg</span>(<span class="hljs-params">url</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image();    img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"一张图片加载完成"</span>);      resolve(img);    &#125;;    img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Could not load image at'</span> + url));    &#125;;    img.src = url;&#125;);</code></pre><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://juejin.im/post/5e58c618e51d4526ed66b5cf#heading-52" target="_blank" rel="noopener">https://juejin.im/post/5e58c618e51d4526ed66b5cf#heading-52</a></p><p><a href="https://juejin.im/post/5d01adb2f265da1b667bd4ad#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5d01adb2f265da1b667bd4ad#heading-5</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>资源加载标签和页面加载</title>
    <link href="/2020/07/18/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A0%87%E7%AD%BE%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/07/18/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A0%87%E7%AD%BE%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="资源加载标签和页面加载"><a href="#资源加载标签和页面加载" class="headerlink" title="资源加载标签和页面加载"></a>资源加载标签和页面加载</h1><h2 id="一、link标签和script标签"><a href="#一、link标签和script标签" class="headerlink" title="一、link标签和script标签"></a>一、link标签和script标签</h2><h3 id="1、link标签"><a href="#1、link标签" class="headerlink" title="1、link标签"></a>1、link标签</h3><p>HTML外部资源链接元素。引用资源，一般引用样式表和图标。</p><p>常见属性：</p><ul><li><p>rel：relationship，一般表示该 link 里加载的资源与文档的关系。（stylesheet、icon、preload*等等）</p></li><li><p>href：资源加载路径。</p></li><li><p>type：文件类型。</p></li><li><p>media：媒体类型，该资源只在满足媒体条件的情况下才被加载进来。</p></li><li><p>crossorigin：可取值 anonymous 和 use-credentials，</p><p>anonymous 发起一个跨域请求(即包含 <code>Origin:</code> HTTP 头)，但不会发送任何认证信息。</p><p>use-credentials 发起一个跨域请求 (即包含 <code>Origin:</code> HTTP 头)，带有认证信息 (发送 cookie, X.509 证书和 HTTP 基本认证信息) 。</p><p>不设置此属性时, 资源将会不使用 CORS 加载。</p></li></ul><h3 id="2、script标签"><a href="#2、script标签" class="headerlink" title="2、script标签"></a>2、script标签</h3><p>嵌入或引用可执行脚本。</p><p>常见属性及作用：</p><ul><li>src：指定该属性的script标签内不应该有脚本。</li><li>crossorigin：同上。</li><li>type：text/javascript，application/javascript；当指定为 module 时，就会被认为加载了JS模块。</li><li>async：该脚本会被并行请求，下载完成后暂停 HTML 解析并立即解析执行，多个 async 的脚本是无序执行的。</li><li>defer：该脚本将在文档完成解析后，触发 <code>DOMContentLoaded</code> 事件前执行。有 <code>defer</code> 属性的脚本会阻止 <code>DOMContentLoaded</code> 事件，直到脚本被加载并且解析完成。如果缺少<code>src</code> 属性（即内嵌脚本），该属性不起作用。“在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本”–《JS高程》</li></ul><img src="https://i.loli.net/2020/07/18/cJFxpQmksnMi3SD.png" srcset="/img/loading.gif" alt="preview" style="zoom:67%;" /><h2 id="二、页面加载时触发的事件"><a href="#二、页面加载时触发的事件" class="headerlink" title="二、页面加载时触发的事件"></a>二、页面加载时触发的事件</h2><h3 id="1、readystatechange"><a href="#1、readystatechange" class="headerlink" title="1、readystatechange"></a>1、readystatechange</h3><ol><li><p>定义：document.readyState属性描述了document的加载状态。</p></li><li><p>取值：</p><ul><li>loading：正在加载。</li><li>interactive：文档加载完毕并且被解析，但是像图片等子资源仍在加载。</li><li>complete：文档和子资源已经加载完毕，表明将要触发load事件。</li></ul></li></ol><h3 id="2、DOMContentLoaded"><a href="#2、DOMContentLoaded" class="headerlink" title="2、DOMContentLoaded"></a>2、DOMContentLoaded</h3><ol><li>定义：一个document上的事件，当完整的 DOM 树形成后就触发，而无需等待样式表、图像等完成加载。load 事件应该用于检测 一个完全加载的页面。</li><li>注意：DOMContentLoaded 事件必须等待其所属script之前link里的样式表加载解析完成才会触发，这是因为 JS 可以查询对象的样式，但是如果将link置于script之后，就不受影响。</li></ol><h3 id="3、load"><a href="#3、load" class="headerlink" title="3、load"></a>3、load</h3><p>定义：当整个页面及所有依赖资源如样式表和图片都已完成加载就触发 load 事件。</p><h3 id="4、三个事件的顺序"><a href="#4、三个事件的顺序" class="headerlink" title="4、三个事件的顺序"></a>4、三个事件的顺序</h3><p>（loading）</p><p>readystate: interactive<br>DOMContentLoaded<br>readystate: complete<br>load</p><p>注：interactive 和 DOMContentLoaded 的触发时间大致接近，但本质还是不同的。</p><p>据《JS高程》第13章的描述，这些事件的触发顺序会因为页面的不同而不尽相同，但是大致的顺序就是 MDN 上描述的。</p><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script</a>    </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded</a></p><p><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html" target="_blank" rel="noopener">https://www.cnblogs.com/caizhenbo/p/6679478.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/load" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Events/load</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从零配置简单Webpack</title>
    <link href="/2020/07/18/Webpack%E7%AE%80%E8%A6%81%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/07/18/Webpack%E7%AE%80%E8%A6%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="从零配置简单Webpack"><a href="#从零配置简单Webpack" class="headerlink" title="从零配置简单Webpack"></a>从零配置简单Webpack</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><pre><code class="hljs shell">npm init -ynpm install webpack webpack-cli --save-dev</code></pre><p>注意：npm初始化后的 package.json 里的 name 属性不能与 webpack 同名。</p><h2 id="二、创建配置文件"><a href="#二、创建配置文件" class="headerlink" title="二、创建配置文件"></a>二、创建配置文件</h2><p>一般有两种方法：</p><ol><li>基础配置文件 + 开发环境配置文件 + 生产环境配置文件</li><li>开发环境配置文件 + 生产环境配置文件</li></ol><p>这里用第二种：根目录下创建 webpack.dev.js 和 webpack.prod.js 两个文件。</p><p>然后在 package.json 里添加两个脚本：</p><pre><code class="hljs json">"build": "webpack --config webpack.prod.js","dev": "webpack-dev-server --config webpack.dev.js"</code></pre><h2 id="三、安装常用loader和plugin"><a href="#三、安装常用loader和plugin" class="headerlink" title="三、安装常用loader和plugin"></a>三、安装常用loader和plugin</h2><p>安装：</p><pre><code class="hljs shell">npm install webpack-dev-server --save-devnpm install html-webpack-plugin --save-devnpm install css-loader --save-devnpm install style-loader --save-devnpm install sass-loader node-sass --save-devnpm install clean-webpack-plugin --save-devnpm install @babel/core @babel/preset-env babel-loader --save-devnpm install file-loader --save-devnpm install url-loader --save-devnpm install html-loader --save-devnpm install mini-css-extract-plugin --save-devnpm install postcss-preset-env postcss-loader --save-devnpm install optimize-css-assets-webpack-plugin --save-devnpm install @babel/polyfill --save-devnpm install core-js --save-dev</code></pre><p>作用：</p><ul><li>webpack-dev-server：开启调试的服务器。</li><li>html-webpack-plugin：处理html。</li><li>css-loader：处理css文件。</li><li>style-loader：将处理好的css代码引入到style标签内。</li><li>sass-loader node-sass：处理sass。</li><li>clean-webpack-plugin：在重新生成打包文件夹前将dist文件夹删除。</li><li>@babel/core @babel/preset-env babel-loader：大部分 es6–&gt;es5，promise 等无法转换。</li><li>file-loader：处理各类资源文件（字体图标、视频等）。</li><li>url-loader：处理（图片）路径。</li><li>html-loader：处理html内的img标签。</li><li>mini-css-extract-plugin：将css代码从bundle.js中分离成单个文件。</li><li>postcss-preset-env postcss-loader：前者处理css最新语法的兼容性问题，自动加浏览器内核前缀，注意在package.json配置browserslist；后者是处理css的工具集，看具体配置了什么。</li><li>optimize-css-assets-webpack-plugin：压缩css。</li><li>@babel/polyfill：谨慎引入polyfill，会导致打包后的js文件变巨大，用法是在入口文件引入import ‘@babel/polyfill’，配置文件无需更改。</li><li>core-js：按需处理js兼容性问题，就不再需要 @babel/polyfill 了。</li></ul><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><pre><code class="hljs json"><span class="hljs-comment">// package.json</span>"browserslist":&#123;    "development":[      "last 1 chrome version",      "last 1 firefox version",      <span class="hljs-string">"last 1 safari version"</span>    ],    "production":[      "&gt;0.2%",      "not dead",      <span class="hljs-string">"not op_mini all"</span>    ]&#125;<span class="hljs-comment">// 测试browserlist里的开发环境，需要给Node.js定环境变量，</span><span class="hljs-comment">// 而不是修改webpack的开发模式（默认为生产环境）。</span><span class="hljs-comment">// webpack.dev.js</span>process.env.NODE_ENV = 'development'</code></pre><pre><code class="hljs js"><span class="hljs-comment">// webpack.dev.js</span><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-keyword">const</span> OptimizeCssAssetsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'development'</span>,  entry: resolve(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>),  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>,    path: resolve(__dirname, <span class="hljs-string">'dist'</span>)  &#125;,  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="hljs-regexp">/\.css$/</span>,        use: [          MiniCssExtractPlugin.loader,           <span class="hljs-string">'css-loader'</span>,          &#123;            loader: <span class="hljs-string">'postcss-loader'</span>,            options: &#123;              ident: <span class="hljs-string">'postcss'</span>, <span class="hljs-comment">// webpack要求要给的唯一标识</span>              plugins:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>[                <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-preset-env'</span>)()              ]            &#125;          &#125;        ]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.scss$/</span>,        use: [&#123;          loader: MiniCssExtractPlugin.loader <span class="hljs-comment">// 将 JS 字符串生成为 style 节点</span>        &#125;, &#123;          loader: <span class="hljs-string">"css-loader"</span> <span class="hljs-comment">// 将 CSS 转化成 CommonJS 模块</span>        &#125;, &#123;          loader: <span class="hljs-string">"sass-loader"</span> <span class="hljs-comment">// 将 Sass 编译成 CSS</span>        &#125;]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.js$/</span>,        loader: [<span class="hljs-string">'babel-loader'</span>],        include: resolve(__dirname, <span class="hljs-string">'src'</span>),        exclude: <span class="hljs-regexp">/node_modules/</span>,        options:&#123;          presets:[            <span class="hljs-string">'@babel/preset-env'</span>,            &#123;              <span class="hljs-comment">// 按需加载</span>              useBuiltIns: <span class="hljs-string">'usage'</span>,              <span class="hljs-comment">// 指定core-js版本</span>              corejs:&#123;                version: <span class="hljs-number">3</span>              &#125;,              <span class="hljs-comment">// 指定兼容性做到哪个版本浏览器</span>              target:&#123;                chrome: <span class="hljs-string">'60'</span>,                firefox: <span class="hljs-string">'60'</span>,                ie: <span class="hljs-string">'9'</span>,                safari: <span class="hljs-string">'10'</span>,                edge: <span class="hljs-string">'17'</span>              &#125;            &#125;          ]        &#125;      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,        use: [          &#123;            loader: <span class="hljs-string">'url-loader'</span>,            options: &#123;              name: <span class="hljs-string">'[hash:5].[ext]'</span>,              limit: <span class="hljs-number">8192</span>,              <span class="hljs-comment">// 默认情况下url-loader用es6的方法引入，跟html-loader配合时会出错，所以要设置为false</span>              esModule: <span class="hljs-literal">false</span>            &#125;          &#125;        ]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(html)$/</span>,        use: &#123;          loader: <span class="hljs-string">'html-loader'</span>        &#125;      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/</span>,        <span class="hljs-comment">// 或者排除html/css/js/scss等其他处理过的</span>        <span class="hljs-comment">// exclude: /\.(html|css|js|scss)$/,</span>        loader: <span class="hljs-string">' file-loader'</span>,        options: &#123;          name: <span class="hljs-string">'[hash:5].[ext]'</span>        &#125;      &#125;    ]  &#125;,  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      <span class="hljs-comment">// 模板</span>      template: resolve(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),      <span class="hljs-comment">// 输出文件名</span>      filename: <span class="hljs-string">'index.html'</span>    &#125;),    <span class="hljs-comment">// 使用MiniCssExtractPlugin就要把所有style-loader换成MiniCssExtractPlugin.loader</span>    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;      <span class="hljs-comment">// filename: 'css/main.css'</span>    &#125;),    <span class="hljs-keyword">new</span> OptimizeCssAssetsPlugin()  ],  devServer: &#123;    port: <span class="hljs-number">3000</span>,    contentBase: resolve(__dirname, <span class="hljs-string">'dist'</span>),    open: <span class="hljs-literal">true</span>,    compress: <span class="hljs-literal">true</span>,    hot: <span class="hljs-literal">true</span>  &#125;,  <span class="hljs-comment">// 方便调试</span>  devtool: <span class="hljs-string">'cheap-module-eval-source-map'</span>&#125;</code></pre><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>)<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-keyword">const</span> OptimizeCssAssetsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'production'</span>,  entry: resolve(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.js'</span>),  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>,    path: resolve(__dirname, <span class="hljs-string">'dist'</span>)  &#125;,  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="hljs-regexp">/\.css$/</span>,        use: [          MiniCssExtractPlugin.loader,          <span class="hljs-string">'css-loader'</span>,          &#123;            loader: <span class="hljs-string">'postcss-loader'</span>,            options: &#123;              ident: <span class="hljs-string">'postcss'</span>, <span class="hljs-comment">// webpack要求要给的唯一标识</span>              plugins:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>[                <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-preset-env'</span>)()              ]            &#125;          &#125;        ]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.scss$/</span>,        use: [&#123;          loader: MiniCssExtractPlugin.loader <span class="hljs-comment">// 将 JS 字符串生成为 style 节点</span>        &#125;, &#123;          loader: <span class="hljs-string">"css-loader"</span> <span class="hljs-comment">// 将 CSS 转化成 CommonJS 模块</span>        &#125;, &#123;          loader: <span class="hljs-string">"sass-loader"</span> <span class="hljs-comment">// 将 Sass 编译成 CSS</span>        &#125;]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.js$/</span>,        loader: [<span class="hljs-string">'babel-loader'</span>],        include: resolve(__dirname, <span class="hljs-string">'src'</span>),        exclude: <span class="hljs-regexp">/node_modules/</span>,        options:&#123;          presets:[            <span class="hljs-string">'@babel/preset-env'</span>,            &#123;              <span class="hljs-comment">// 按需加载</span>              useBuiltIns: <span class="hljs-string">'usage'</span>,              <span class="hljs-comment">// 指定core-js版本</span>              corejs:&#123;                version: <span class="hljs-number">3</span>              &#125;,              <span class="hljs-comment">// 指定兼容性做到哪个版本浏览器</span>              target:&#123;                chrome: <span class="hljs-string">'60'</span>,                firefox: <span class="hljs-string">'60'</span>,                ie: <span class="hljs-string">'9'</span>,                safari: <span class="hljs-string">'10'</span>,                edge: <span class="hljs-string">'17'</span>              &#125;            &#125;          ]        &#125;      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,        use: [          &#123;            loader: <span class="hljs-string">'url-loader'</span>,            options: &#123;              name: <span class="hljs-string">'[hash:5].[ext]'</span>,              limit: <span class="hljs-number">8192</span>,              <span class="hljs-comment">// 默认情况下url-loader用es6的方法引入，跟html-loader配合时会出错，所以要设置为false</span>              esModule: <span class="hljs-literal">false</span>            &#125;          &#125;        ]      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(html)$/</span>,        use: &#123;          loader: <span class="hljs-string">'html-loader'</span>        &#125;      &#125;,      &#123;        test: <span class="hljs-regexp">/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/</span>,        <span class="hljs-comment">// 或者排除html/css/js/scss等其他处理过的</span>        <span class="hljs-comment">// exclude: /\.(html|css|js|scss)$/,</span>        loader: <span class="hljs-string">' file-loader'</span>,        options: &#123;          name: <span class="hljs-string">'[hash:5].[ext]'</span>        &#125;      &#125;    ]  &#125;,  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      <span class="hljs-comment">// 模板</span>      template: resolve(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'index.html'</span>),      <span class="hljs-comment">// 输出文件名</span>      filename: <span class="hljs-string">'index.html'</span>,      <span class="hljs-comment">// 压缩HTML</span>      minify:&#123;        collapseWhitespace: <span class="hljs-literal">true</span>,        removeComments: <span class="hljs-literal">true</span>      &#125;    &#125;),    <span class="hljs-comment">// 使用MiniCssExtractPlugin就要把所有style-loader换成MiniCssExtractPlugin.loader</span>    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;      <span class="hljs-comment">// filename: 'css/main.css'</span>    &#125;),    <span class="hljs-keyword">new</span> OptimizeCssAssetsPlugin()  ],  <span class="hljs-comment">// 分割代码，像vue的脚手架生成的js文件一样有多个，也即多个chunk。并且会分析有无相同的文件。</span>  optimization: &#123;    splitChunks: &#123;      chunks: <span class="hljs-string">'all'</span>    &#125;  &#125;&#125;</code></pre><p>开发环境和生产环境的配置，按实际情况更改。</p><p>例如配置eslint，上面无配置，一般ide就能实现，这里仅作补充。</p><pre><code class="hljs shell">npm install eslint-config-airbnb-base eslint-plugin-import eslint --save-dev</code></pre><pre><code class="hljs js"><span class="hljs-comment">// webpack配置文件</span>&#123;  test: <span class="hljs-regexp">/\.js$/</span>,  exclude: <span class="hljs-regexp">/node_modules/</span>,  loader: <span class="hljs-string">'eslint-loader'</span>,  options: &#123;    fix: <span class="hljs-literal">true</span>  &#125;&#125;</code></pre><pre><code class="hljs json"><span class="hljs-comment">// package.json</span>"eslintConfig": &#123;    "extends": "airbnb-base"&#125;</code></pre><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><p><a href="https://juejin.im/post/5b4609f5e51d4519596b66a7" target="_blank" rel="noopener">https://juejin.im/post/5b4609f5e51d4519596b66a7</a></p><p><a href="https://www.npmjs.com/package/postcss-loader" target="_blank" rel="noopener">https://www.npmjs.com/package/postcss-loader</a></p><p><a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a></p><p><a href="https://www.npmjs.com/package/postcss-preset-env" target="_blank" rel="noopener">https://www.npmjs.com/package/postcss-preset-env</a></p>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h1><h2 id="一、DOCTYPE"><a href="#一、DOCTYPE" class="headerlink" title="一、DOCTYPE"></a>一、DOCTYPE</h2><p>DOCTYPE 是用来声明文档类型和 DTD 规范的，主要用途是合法性验证，并告诉浏览器 HTML 版本。</p><p>&lt;!DOCTYPE&gt; 不是 HTML  标签，是声明，并且不区分大小写。</p><h2 id="二、浏览器渲染过程"><a href="#二、浏览器渲染过程" class="headerlink" title="二、浏览器渲染过程"></a>二、浏览器渲染过程</h2><img src="https://i.loli.net/2020/07/18/W6cAyGFZdYVJf8b.png" srcset="/img/loading.gif" alt="img" style="zoom: 50%;" /><ul><li>解析 HTML 代码构建 DOM 树，解析 CSS 代码构建 CSSOM 规则树；</li><li>根据 DOM 和 CSSOM 构建 Render Tree  ；</li><li>利用 Render Tree 对页面进行布局和绘制，最后显示；</li></ul><p>关于阻塞：在解析 HTML 代码时，遇到&lt;script&gt; 浏览器会先下载和构建CSSOM，然后执行脚本，最后才是继续构建DOM。</p><p>（原因：不完整的 CSSOM 是无法使用的。并且在执行脚本的时候会暂停 DOM 的构建，所以建议把脚本放在 body 最后。）</p><h2 id="三、Reflow"><a href="#三、Reflow" class="headerlink" title="三、Reflow"></a>三、Reflow</h2><ol><li><p>定义：回流、重排，当对 DOM 的修改导致 DOM 发生变化（指大小、隐藏等），其他元素也会受影响，浏览器根据计算结果绘制页面。一个页面至少会回流一次，就是第一次加载的时候。</p></li><li><p>触发方式：</p></li></ol><ul><li>添加、删除、修改、移动DOM；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度；</li><li>浏览器窗口尺寸改变——resize事件发生时；</li><li>计算 offsetWidth 和 offsetHeight 属性；</li><li>内容变化，比如用户在input框中输入文字；</li><li>设置 style 属性的值。</li></ul><h2 id="四、Repaint"><a href="#四、Repaint" class="headerlink" title="四、Repaint"></a>四、Repaint</h2><ol><li>定义：重绘，当对 DOM 的修改不影响布局时，只是背景色、字体颜色等等的修改，浏览器不需重新计算，直接为元素绘制样式。回流必定会发生重绘，重绘不一定会引发回流。</li><li>触发方式：</li></ol><ul><li>修改字体、背景样式；</li><li>修改盒子边框曲率；</li><li>各种不影响尺寸、布局的方法。</li></ul><h2 id="五、dispaly-none-和-visibility-hidden"><a href="#五、dispaly-none-和-visibility-hidden" class="headerlink" title="五、dispaly:none 和 visibility:hidden"></a>五、dispaly:none 和 visibility:hidden</h2><ol><li><p>定义：</p><p>dispaly:none ：元素隐藏，占据的空间消失。</p><p>visibility:hidden ：元素隐藏，依然占据空间。</p></li><li><p>区别：</p></li></ol><ul><li>visibility具有继承性，给父元素设置visibility: hidden子元素会继承。但如果给子元素设置visibility: visible,则子元素又会显示。</li><li>visibility: hidden不会影响计数器的计数，例如ol&gt;li标签的序号排列，display: none会始终排出连续的号，visibility: hidden不会。*</li><li>CSS3 的 transition 支持visibility属性，但是并不支持display。**</li><li>display: none会引起回流和重绘，visibility:hidden 只会引起重绘。</li></ul><ol start="3"><li><p>补充：</p><p>*：</p><img src="https://i.loli.net/2020/07/18/o8M6zc3e12lNxSm.png" srcset="/img/loading.gif" alt="image-20200718171733270" style="zoom: 67%;" /><p>**：</p><pre><code class="hljs html">CSS代码：.trans-fadeout&#123;   -webkit-transition:all 0.5s linear;   -moz-transition:all 0.5s linear;   -ms-transition:all 0.5s linear;   -o-transition:all 0.5s linear;   transition:all 0.5s linear;&#125;.image-fadeout&#123;position:absolute; margin-top:20px; visibility:hidden; opacity:0;&#125;.hover-fadeout:hover .image-fadeout&#123; visibility:visible; opacity:1; &#125;HTML代码：<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hover-fadeout"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//image.zhangxinxu.com/image/study/s/s256/mm1.jpg"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"trans-fadeout image-fadeout"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>经过我显示图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>继承、作用域和闭包</title>
    <link href="/2020/07/16/inheritscopeclosure/"/>
    <url>/2020/07/16/inheritscopeclosure/</url>
    
    <content type="html"><![CDATA[<h1 id="继承、作用域和闭包"><a href="#继承、作用域和闭包" class="headerlink" title="继承、作用域和闭包"></a>继承、作用域和闭包</h1><h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>ES5 的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到this上面（ Parent.apply(this) ）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。所以在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</p><h3 id="1-使用传统方法"><a href="#1-使用传统方法" class="headerlink" title="1. 使用传统方法"></a>1. 使用传统方法</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>)</span>&#123;  <span class="hljs-keyword">this</span>.name = name&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, age</span>)</span>&#123;  Parent.call(<span class="hljs-keyword">this</span>, name)  <span class="hljs-keyword">this</span>.age = age&#125;Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype)Child.prototype.constructor = Child<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Child()</code></pre><h3 id="2-使用Class"><a href="#2-使用Class" class="headerlink" title="2. 使用Class"></a>2. 使用Class</h3><p>类的数据类型是 函数，类本身指向 构造函数。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;&#125;<span class="hljs-keyword">typeof</span> Point <span class="hljs-comment">// "function"</span>Point === Point.prototype.constructor <span class="hljs-comment">// true</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(x, y) &#123;    <span class="hljs-keyword">this</span>.x = x;    <span class="hljs-keyword">this</span>.y = y;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(x, y, color) &#123;    <span class="hljs-keyword">super</span>(x, y);    <span class="hljs-keyword">this</span>.color = color;  &#125;&#125;<span class="hljs-keyword">let</span> cp = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-number">25</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'green'</span>);cp <span class="hljs-keyword">instanceof</span> ColorPoint <span class="hljs-comment">// true</span>cp <span class="hljs-keyword">instanceof</span> Point <span class="hljs-comment">// true</span></code></pre><p>关于 super 的补充：</p><ul><li>内部的 this 指向子类。</li><li>只能在子类的 constructor 里调用。</li><li>可以当作函数使用，也可以当作对象使用。</li><li>作为函数时，代表父类的构造函数。</li><li>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li></ul><h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><ul><li><p>ES5 中只有 全局作用域 和 函数作用域，ES6 中新增 块级作用域。</p></li><li><p>在 JavaScript  中，一个变量名进入作用域的方式有 4 种：</p></li></ul><ol><li>Language-defined：所有的作用域默认都会给出 <code>this</code> 和 <code>arguments</code> 两个变量名（global没有<code>arguments</code>）;</li><li>Formal parameters（形参）：函数有形参，形参会添加到函数的作用域中;</li><li>Function declarations（函数声明）：如 <code>function foo() {}</code>;</li><li>Variable declarations（变量声明）：如 <code>var foo</code>，包括 函数表达式。</li></ol><ul><li><p>函数声明和变量声明总是会被移动到它们所在的作用域的顶部，而变量的解析顺序（优先级），与变量进入作用域的4种方式的顺序一致。</p></li><li><p>this 的指向是执行时确定的。</p></li></ul><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><p>闭包是作用域的一个应用。</p><ol><li>将函数作为返回值，把原函数内的变量带出去</li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a)  &#125;&#125;<span class="hljs-keyword">const</span> fn = create()<span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span>fn() <span class="hljs-comment">//100</span></code></pre><ol start="2"><li>传入一个函数作为参数，调用原函数内的变量</li></ol><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">fn</span>) </span>&#123;  <span class="hljs-keyword">const</span> a = <span class="hljs-number">200</span>  fn() &#125;<span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span>print(fn) <span class="hljs-comment">//100</span></code></pre><h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="1-this-的指向"><a href="#1-this-的指向" class="headerlink" title="1. this 的指向"></a>1. this 的指向</h3><p>在函数执行时，this 会默认指向 window 先，然后再根据具体情况，赋其他值给 this。严格模式下 this 为 null。</p><p>1）全局的普通函数指向window</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)&#125;f() <span class="hljs-comment">// window</span></code></pre><p>2）对象的函数指向该对象</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  f()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)  &#125;,  timeout()&#123;    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// this 默认指向 window</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)    &#125;, <span class="hljs-number">1000</span>);  &#125;&#125;obj.f() <span class="hljs-comment">// obj</span>obj.timeout() <span class="hljs-comment">// window</span></code></pre><p>3）箭头函数指向上级作用域的 this，箭头函数本身没有 this</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  f()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)  &#125;,  timeout()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)     setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)     &#125;, <span class="hljs-number">1000</span>);  &#125;&#125;obj.f() <span class="hljs-comment">// obj</span>obj.timeout() <span class="hljs-comment">// obj obj</span></code></pre><p>4）构造函数/类指向实例本身</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-keyword">constructor</span>(name,age)&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);  &#125;&#125;<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'lll'</span>,<span class="hljs-number">18</span>); <span class="hljs-comment">// Person &#123;name: "lll", age: 18&#125;</span>****************************************************************<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-keyword">this</span>.age = age;  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'lll'</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// Person &#123;name: "lll", age: 18&#125;</span></code></pre><p>5）bind\call\apply 指向传入的第一个实参</p><p>bind 方法的返回值是函数，并且需要稍后调用才会执行，而 apply 和 call 则是立即调用。</p><pre><code class="hljs js"><span class="hljs-comment">// 手写bind\call\apply</span><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;  <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>)  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> self.apply(context,args)  &#125;&#125;<span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;   context.fn = <span class="hljs-keyword">this</span>  <span class="hljs-keyword">const</span> args = [...arguments].slice(<span class="hljs-number">1</span>)  context.fn(args)  <span class="hljs-keyword">delete</span> context.fn&#125;<span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;  context.fn = <span class="hljs-keyword">this</span>  <span class="hljs-keyword">const</span> arg = [...arguments].slice(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]  <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'the second parms must be Array!'</span>)  &#125;  context.fn(arg)  <span class="hljs-keyword">delete</span> context.fn&#125;</code></pre><h3 id="2-闭包的应用"><a href="#2-闭包的应用" class="headerlink" title="2. 闭包的应用"></a>2. 闭包的应用</h3><pre><code class="hljs js"><span class="hljs-comment">// 用于暂存数据</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCache</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> data = &#123;&#125;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-keyword">set</span>: function(key, value) &#123;      data[key]= value    &#125;,    <span class="hljs-keyword">get</span>: function(key) &#123;      <span class="hljs-keyword">return</span> data[key]    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2020/07/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/07/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><h2 id="一、创建对象的方法"><a href="#一、创建对象的方法" class="headerlink" title="一、创建对象的方法"></a>一、创建对象的方法</h2><pre><code class="hljs js"><span class="hljs-comment">//1.字面量</span><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'solo obj1'</span>&#125;;<span class="hljs-comment">//2.new Object</span><span class="hljs-keyword">var</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'solo obj2'</span>&#125;)<span class="hljs-comment">//3.构造函数创建</span><span class="hljs-keyword">var</span> M = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-keyword">var</span> obj3 = <span class="hljs-keyword">new</span> M(<span class="hljs-string">'solo obj3'</span>);<span class="hljs-comment">//4.Object.create</span><span class="hljs-keyword">var</span> p = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'p'</span>&#125;;<span class="hljs-keyword">var</span> obj4 = <span class="hljs-built_in">Object</span>.create(p);</code></pre><h2 id="二、原型、构造函数、实例的关系"><a href="#二、原型、构造函数、实例的关系" class="headerlink" title="二、原型、构造函数、实例的关系"></a>二、原型、构造函数、实例的关系</h2><img src="https://i.loli.net/2020/07/15/84kOSeHWFVsb1iC.png" srcset="/img/loading.gif" alt="img" style="zoom: 50%;" /><h2 id="三、instanceof的原理"><a href="#三、instanceof的原理" class="headerlink" title="三、instanceof的原理"></a>三、instanceof的原理</h2><p>原理：判断实例对象的 __proto__是否与构造函数的 prototype 指向同一个引用。</p><p>作用：判断一个引用类型是否属于某构造函数；在继承关系中用来判断一个实例是否属于它的父类型。</p><p>所以只要在实例对象的原型链上的构造函数，instaceof 都会返回 true，如果想准确的判断构造函数究竟是哪个，可以用 constructor。</p><h2 id="四、instanceof和typeof的区别"><a href="#四、instanceof和typeof的区别" class="headerlink" title="四、instanceof和typeof的区别"></a>四、instanceof和typeof的区别</h2><p>typeof 对于基本数据类型（null, undefined, string, number, boolean, symbol），除了 null 都会返回正确的类型。null 会返回 object。typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。</p><p>如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。</p><p>用 void 0 可以安全的获得 undefined 来判断一个变量是不是 undefined 。</p><h2 id="五、new关键字"><a href="#五、new关键字" class="headerlink" title="五、new关键字"></a>五、new关键字</h2><p>概念：创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p>过程：</p><ol><li>创建一个空的简单JavaScript对象（即<code>{}</code>）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li><li>如果该函数没有返回对象，则返回<code>this</code>。</li></ol><p>创建一个用户自定义的对象需要两步：</p><ol><li>通过编写函数来定义对象类型。</li><li>通过 <code>new</code> 来创建对象实例。</li></ol><p>创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</p><ol><li>一个继承自 <code>Foo.prototype</code> 的新对象被创建。</li><li>使用指定的参数调用构造函数 <code>Foo</code>，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()</code>，也就是没有指定参数列表，<code>Foo</code>不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件</title>
    <link href="/2020/07/13/domevent/"/>
    <url>/2020/07/13/domevent/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><h2 id="1、事件级别"><a href="#1、事件级别" class="headerlink" title="1、事件级别"></a>1、事件级别</h2><ul><li>DOM0：element.onclick = function(){}</li><li>DOM2：element.addEventListener(‘click’, function(){}, false)</li><li>DOM3：element.addEventListener(‘keyup’, function(){}, false)</li></ul><p>注意：没有 DOM1是因为标准制定的时候没有涉及 DOM事件，据《JavaScript高级程序设计》DOM1主要是HTML和XML文档的底层结构。DOM3 是 DOM2 的补充。</p><h2 id="2、捕获和冒泡"><a href="#2、捕获和冒泡" class="headerlink" title="2、捕获和冒泡"></a>2、捕获和冒泡</h2><p>捕获的流程由外到内：window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素。</p><p>冒泡的流程由内到外：目标元素 -&gt; … -&gt; body -&gt; html -&gt; document -&gt; window。</p><h2 id="3、常见方法"><a href="#3、常见方法" class="headerlink" title="3、常见方法"></a>3、常见方法</h2><ol><li>event.preventDefault()：取消事件的默认动作。</li><li>event.stopPropagation()：阻止事件冒泡，不再传播。</li><li>event.stopImmediatePropagation()：阻止监听同一事件的其他事件监听器被调用。如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了event.stopImmediatePropagation() 方法，则当前元素剩下的监听函数将不会被执行。</li></ol><h2 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h2><pre><code class="hljs js"><span class="hljs-comment">// event.preventDefault()</span><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#id-checkbox"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"output-box"</span>).innerHTML += <span class="hljs-string">"Sorry! &lt;code&gt;preventDefault()&lt;/code&gt; won't let you check this!&lt;br&gt;"</span>;    <span class="hljs-comment">// 多选框将无法选中</span>    event.preventDefault();&#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// event.stopImmediatePropagation()</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'p'</span>)p.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; &#123;    alert(<span class="hljs-string">"我是p元素上被绑定的第一个监听函数"</span>);&#125;, <span class="hljs-literal">false</span>);p.addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; &#123;alert(<span class="hljs-string">"我是p元素上被绑定的第二个监听函数"</span>);    event.stopImmediatePropagation();    <span class="hljs-comment">// 执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span>&#125;, <span class="hljs-literal">false</span>);p.addEventListener(<span class="hljs-string">"click"</span>,(event) =&gt; &#123;    alert(<span class="hljs-string">"我是p元素上被绑定的第三个监听函数"</span>);    <span class="hljs-comment">// 该监听函数排在上个函数后面，该函数不会被执行</span>&#125;, <span class="hljs-literal">false</span>);<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"div"</span>).addEventListener(<span class="hljs-string">"click"</span>, (event) =&gt; &#123;    alert(<span class="hljs-string">"我是div元素,我是p元素的上层元素"</span>);    <span class="hljs-comment">// p元素的click事件没有向上冒泡，该函数不会被执行</span>&#125;, <span class="hljs-literal">false</span>);</code></pre><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>盒子模型</title>
    <link href="/2020/07/13/cssbox/"/>
    <url>/2020/07/13/cssbox/</url>
    
    <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>一个盒子包括：外边距、边框、内边距和实际内容。</p><img src="https://i.loli.net/2020/07/13/xDcrPEKMRydt8QI.png" srcset="/img/loading.gif" alt="img" style="zoom: 50%;" /><h2 id="二、标准盒子与-IE-盒子"><a href="#二、标准盒子与-IE-盒子" class="headerlink" title="二、标准盒子与 IE 盒子"></a>二、标准盒子与 IE 盒子</h2><p>标准盒子宽高 = content </p><p>IE盒子宽高 =  content + padding + border </p><img src="https://i.loli.net/2020/07/13/mCh8SvVsKfIAg7P.png" srcset="/img/loading.gif" alt="img" style="zoom: 67%;" /><img src="https://i.loli.net/2020/07/13/xbipVngTRCoDYwc.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /><pre><code class="hljs css">//设置标准盒子，默认<span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">content-box</span>;//设置IE盒子<span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;</code></pre><h2 id="三、获取宽-高"><a href="#三、获取宽-高" class="headerlink" title="三、获取宽/高"></a>三、获取宽/高</h2><pre><code class="hljs js"><span class="hljs-comment">// 只能获取内联样式设置的宽高</span>dom.style.width/height<span class="hljs-comment">// 获取渲染后即时运行的宽高，值是准确的。但只支持 IE</span>dom.currentStyle.width/height<span class="hljs-comment">// 获取渲染后即时运行的宽高，值是准确的。兼容性更好</span><span class="hljs-built_in">window</span>.getComputedStyle(dom).width/height;<span class="hljs-comment">// getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。</span>dom.getBoundingClientRect().width/height/left/top;</code></pre><h2 id="四、BFC-IFC"><a href="#四、BFC-IFC" class="headerlink" title="四、BFC/IFC"></a>四、BFC/IFC</h2><p>1、前置概念：</p><ol><li><p>Box: 布局的基本单位，元素类型和 display 属性，决定 Box 的类型。不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。</p><p>block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block formatting context；</p><p>inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context。</p></li><li><p>Formatting Context：这个概念规定了页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>BFC: Block Formatting Context，块级格式化上下文。</p><p>IFC: Inline Formatting Context，行级格式化上下文。</p></li></ol><p>2、详解：</p><ol><li>BFC：</li></ol><ul><li><p>布局规则：</p><ul><li>内部的Box会在垂直方向一个个放置，盒子之间垂直的间距是由 margin 决定。</li><li>在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul></li><li><p>创建BFC：</p><ul><li>float的值不是none。</li><li>position的值不是static或者relative。</li><li>overflow的值不是visible。</li><li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex。</li></ul></li><li><p>作用：</p><ul><li>利用BFC避免margin重叠。</li><li>自适应两栏布局。</li><li>清除浮动。</li></ul></li></ul><ol start="2"><li>IFC：</li></ol><ul><li>布局规则：<ul><li>内部的盒子会在水平方向，一个个地放置。</li><li>IFC的高度，由里面最高盒子的高度决定。</li><li>当一行不够放置的时候会自动切换到下一行。</li></ul></li></ul><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p><p><a href="https://segmentfault.com/a/1190000013647777" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013647777</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p><p><a href="https://segmentfault.com/a/1190000013664630" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013664630</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>水平垂直居中的方法</title>
    <link href="/2020/07/13/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/13/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="水平垂直居中的方法"><a href="#水平垂直居中的方法" class="headerlink" title="水平垂直居中的方法"></a>水平垂直居中的方法</h1><h2 id="一、absolute-负margin"><a href="#一、absolute-负margin" class="headerlink" title="一、absolute + 负margin"></a>一、absolute + 负margin</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"out"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span>12345<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: 50%;    top: 50%;    margin-left: -50px;    margin-top: -50px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：好理解，兼容性很好。</p><p>缺点：需要知道子元素的宽高。</p><h2 id="二、absolute-auto-margin"><a href="#二、absolute-auto-margin" class="headerlink" title="二、absolute + auto margin"></a>二、absolute + auto margin</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: 0;    top: 0;    right: 0;    bottom: 0;    margin: auto;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：好理解，兼容性很好。</p><p>缺点：需要知道子元素的宽高。</p><h2 id="三、absolute-calc"><a href="#三、absolute-calc" class="headerlink" title="三、absolute + calc"></a>三、absolute + calc</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: calc(50% - 50px);    top: calc(50% - 50px);  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：容易理解。</p><p>缺点：需要知道子元素的宽高，兼容性一般，需要支持calc。</p><h2 id="四、absolute-transform"><a href="#四、absolute-transform" class="headerlink" title="四、absolute + transform"></a>四、absolute + transform</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    background: yellow;    left: 50%;    top: 50%;    transform: translate(-50%, -50%);  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：不需要知道子元素的宽高。</p><p>缺点：兼容性一般，需要支持translate。</p><h2 id="五、table"><a href="#五、table" class="headerlink" title="五、table"></a>五、table</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: table-cell;    width: 300px;    height: 300px;    text-align: center;    vertical-align: middle;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    display: inline-block;    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：兼容性好。</p><p>缺点：要对table的使用很熟练。</p><h2 id="六、flex"><a href="#六、flex" class="headerlink" title="六、flex"></a>六、flex</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: flex;    justify-content: center;    align-items: center;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：简单。可通过父元素指定子元素的对齐方式，也可通过子元素自己指定自己的对齐方式来实现。</p><h2 id="七、grid"><a href="#七、grid" class="headerlink" title="七、grid"></a>七、grid</h2><pre><code class="hljs html">//方法一：父元素指定子元素的对齐方式<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: grid;    align-content: center;    justify-content: center;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>//方法二：子元素自己指定自己的对齐方式<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: grid;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;    align-self: center;    justify-self: center;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：简单。可通过父元素指定子元素的对齐方式，也可通过子元素自己指定自己的对齐方式来实现。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p><p><a href="https://blog.csdn.net/messagebox_/article/details/82380913" target="_blank" rel="noopener">https://blog.csdn.net/messagebox_/article/details/82380913</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/display</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面布局</title>
    <link href="/2020/07/13/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <url>/2020/07/13/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><p>多种方式实现三栏布局</p><h2 id="一、float布局"><a href="#一、float布局" class="headerlink" title="一、float布局"></a>一、float布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout float"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.wrapper</span>&gt;<span class="hljs-selector-tag">div</span> &#123;</span>        min-height: 100px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.left</span> &#123;</span>        float: left;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.center</span> &#123;</span>        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.right</span> &#123;</span>        float: right;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>float布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是float布局的中间部分        2.我是float布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单，兼容性比较好。注意需要清除浮动。<br>缺点：浮动元素是脱离文档流，清除浮动处理不好会出现高度塌陷等问题。</p><h2 id="二、绝对布局"><a href="#二、绝对布局" class="headerlink" title="二、绝对布局"></a>二、绝对布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout absolute"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        width: 100%;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.wrapper</span>&gt;<span class="hljs-selector-tag">div</span> &#123;</span>        min-height: 100px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.left</span> &#123;</span>        position: absolute;        left: 0;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.center</span> &#123;</span>        position: absolute;        left: 300px;        right: 300px;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.right</span> &#123;</span>        position: absolute;        right: 0;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>absolute布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是absolute布局的中间部分        2.我是absolute布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单，兼容性比较好。<br>缺点：绝对定位是脱离文档流的，下面的所有子元素也会脱离文档流，导致这种方法的有效性和可使用性是比较差的。</p><h2 id="三、flex布局"><a href="#三、flex布局" class="headerlink" title="三、flex布局"></a>三、flex布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout flex"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        width: 100%;        min-height: 100px;        display: flex;        margin-top: 140px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.left</span> &#123;</span>        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.center</span> &#123;</span>        flex: 1;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.right</span> &#123;</span>        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>flex布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是flex布局的中间部分        2.我是flex布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：不支持 IE8 及以下。</p><h2 id="四、table布局"><a href="#四、table布局" class="headerlink" title="四、table布局"></a>四、table布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout table"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        display: table;        width: 100%;        min-height: 100px;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.left</span> &#123;</span>        display: table-cell;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.center</span> &#123;</span>        display: table-cell;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.right</span> &#123;</span>        display: table-cell;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>table布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是table布局的中间部分        2.我是table布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。</p><h2 id="五、grid布局"><a href="#五、grid布局" class="headerlink" title="五、grid布局"></a>五、grid布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout grid"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        display: grid;        grid-template-columns: 300px auto 300px;        grid-template-rows: 100px;        width: 100%;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.left</span> &#123;</span>        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.center</span> &#123;</span>        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.right</span> &#123;</span>        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>grid布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是grid布局的中间部分        2.我是grid布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：不支持 IE8 及以下。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(一)</title>
    <link href="/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
    <url>/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-一"><a href="#设计模式-一" class="headerlink" title="设计模式(一)"></a>设计模式(一)</h1><h2 id="零、原则"><a href="#零、原则" class="headerlink" title="零、原则"></a>零、原则</h2><p><strong>S – Single Responsibility Principle 单一职责原则</strong></p><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul><p><strong>O – OpenClosed Principle 开放/封闭原则</strong></p><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul><p><strong>L – Liskov Substitution Principle 里氏替换原则</strong></p><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul><p><strong>I – Interface Segregation Principle 接口隔离原则</strong></p><ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul><p><strong>D – Dependency Inversion Principle 依赖倒转原则</strong></p><ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul><h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><p>创建对象，使一个类的实例化延迟到了子类内。</p><ul><li><p>模式作用:</p><ol><li>对象的构建十分复杂。</li><li>需要依赖具体的环境创建不同实例。</li><li>处理大量具有相同属性的小对象。</li></ol></li><li><p>注意事项:</p><ol><li>不能滥用工厂，有时候仅仅是给代码增加复杂度。</li></ol></li><li><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 简单工厂</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;  phone()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'iPhone'</span>);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SAMSUNG</span> </span>&#123;  phone()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Galaxy'</span>);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;  create(type)&#123;      <span class="hljs-comment">// 复杂操作</span>    <span class="hljs-keyword">let</span> obj = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">switch</span> (type) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">'Apple'</span>:        obj = <span class="hljs-keyword">new</span> Apple();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'SAMSUNG'</span>:        obj = <span class="hljs-keyword">new</span> SAMSUNG();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No type!'</span>);    &#125;    <span class="hljs-keyword">return</span> obj;  &#125;&#125;<span class="hljs-keyword">let</span> factory = <span class="hljs-keyword">new</span> Factory()<span class="hljs-keyword">let</span> phone1 = factory.create(<span class="hljs-string">'Apple'</span>);<span class="hljs-keyword">let</span> phone2 = factory.create(<span class="hljs-string">'SAMSUNG'</span>);phone1.phone(); <span class="hljs-comment">// iPhone</span>phone2.phone(); <span class="hljs-comment">// Galaxy</span><span class="hljs-comment">// 或者直接添加在工厂类上添加方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;  phone()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'iPhone'</span>);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SAMSUNG</span> </span>&#123;  phone()&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Galaxy'</span>);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;&#125;Factory.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>)</span>&#123;  <span class="hljs-keyword">let</span> obj = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">switch</span> (type) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">'Apple'</span>:        obj = <span class="hljs-keyword">new</span> Apple();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">'SAMSUNG'</span>:        obj = <span class="hljs-keyword">new</span> SAMSUNG();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'No type!'</span>);    &#125;    <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">let</span> phone1 = Factory.create(<span class="hljs-string">'Apple'</span>);<span class="hljs-keyword">let</span> phone2 = Factory.create(<span class="hljs-string">'SAMSUNG'</span>);phone1.phone(); <span class="hljs-comment">// iPhone</span>phone2.phone(); <span class="hljs-comment">// Galaxy</span></code></pre></li></ul><p>拓展：抽象的来说，工厂可以根据类型来生产产品，或是在子类中覆盖或添加其他的东西。</p><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><ul><li><p>模式作用：</p><p>一个单一对象，比如弹窗，无论点击多少次，弹窗只应该被创建一次。</p></li><li><p>示例：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateUser</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name) &#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.getName();    &#125;    getName() &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;&#125;<span class="hljs-comment">// 代理实现单例模式</span><span class="hljs-keyword">var</span> ProxyMode = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;        <span class="hljs-keyword">if</span>(!instance) &#123;            instance = <span class="hljs-keyword">new</span> CreateUser(name);        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;)();<span class="hljs-comment">// 测试单体模式的实例</span><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> ProxyMode(<span class="hljs-string">"aaa"</span>);<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> ProxyMode(<span class="hljs-string">"bbb"</span>);<span class="hljs-comment">// 因为单体模式是只实例化一次，所以下面的实例是相等的</span><span class="hljs-built_in">console</span>.log(a === b);    <span class="hljs-comment">//true</span><span class="hljs-comment">// ************************************************</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'hide'</span>  &#125;  show() &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'show'</span>) &#123;      alert(<span class="hljs-string">'已经显示'</span>)      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'show'</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'登录框显示成功'</span>)  &#125;  hide() &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === <span class="hljs-string">'hide'</span>) &#123;      alert(<span class="hljs-string">'已经隐藏'</span>)      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">this</span>.state = <span class="hljs-string">'hide'</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'登录框隐藏成功'</span>)  &#125;&#125;LoginForm.getInstance = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> instance  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (!instance) &#123;      instance = <span class="hljs-keyword">new</span> LoginForm()    &#125;    <span class="hljs-keyword">return</span> instance  &#125;&#125;)()<span class="hljs-keyword">let</span> obj1 = LoginForm.getInstance()obj1.show()<span class="hljs-keyword">let</span> obj2 = LoginForm.getInstance()obj2.hide()<span class="hljs-built_in">console</span>.log(obj1 === obj2)</code></pre></li></ul><h2 id="三、策略模式"><a href="#三、策略模式" class="headerlink" title="三、策略模式"></a>三、策略模式</h2><p>第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类（不变），接受客户的请求，随后将请求委托给某一个策略类。</p><ul><li><p>作用：</p><ol><li>将实现和使用分开。</li><li>避免多重条件选择语句。</li><li>符合开放-封闭原则，将算法封装在独立的策略中，使得它们易于切换、扩展。</li></ol></li><li><p>示例：</p><pre><code class="hljs javascript"><span class="hljs-comment">/*策略类*/</span><span class="hljs-keyword">var</span> levelOBJ = &#123;    <span class="hljs-string">"A"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">money</span>) </span>&#123;        <span class="hljs-keyword">return</span> money * <span class="hljs-number">4</span>;    &#125;,    <span class="hljs-string">"B"</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">money</span>) </span>&#123;        <span class="hljs-keyword">return</span> money * <span class="hljs-number">3</span>;    &#125;,    <span class="hljs-string">"C"</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">money</span>) </span>&#123;        <span class="hljs-keyword">return</span> money * <span class="hljs-number">2</span>;    &#125; &#125;;<span class="hljs-comment">/*环境类*/</span><span class="hljs-keyword">var</span> calculateBouns =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">level,money</span>) </span>&#123;    <span class="hljs-keyword">return</span> levelOBJ[level](money);&#125;;<span class="hljs-built_in">console</span>.log(calculateBouns(<span class="hljs-string">'A'</span>,<span class="hljs-number">10000</span>)); <span class="hljs-comment">// 40000</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>预处理器</title>
    <link href="/2020/07/06/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2020/07/06/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><h2 id="一、什么是CSS预处理器"><a href="#一、什么是CSS预处理器" class="headerlink" title="一、什么是CSS预处理器"></a>一、什么是CSS预处理器</h2><p>CSS预处理器会是能让你通过预处理器独有的语法来生成CSS。还增加一些原生CSS不具备的特性，让CSS的结构更加具有可读性且易于维护。帮助更好地组织CSS代码，提高代码的复用率，提升可维护性。但是有学习使用成本。</p><p>常见的有Sass、LESS、PostCSS 和 Stylus。</p><h2 id="二、Sass"><a href="#二、Sass" class="headerlink" title="二、Sass"></a>二、Sass</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><pre><code class="hljs scss"><span class="hljs-variable">$side</span> : left;<span class="hljs-variable">$black</span> : <span class="hljs-number">#000</span>.rounded &#123;color: <span class="hljs-variable">$black</span>;<span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$side</span>&#125;-radius: <span class="hljs-number">5px</span>;&#125;</code></pre><h3 id="2-计算"><a href="#2-计算" class="headerlink" title="2. 计算"></a>2. 计算</h3><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">margin</span>: (<span class="hljs-number">14px</span>/<span class="hljs-number">2</span>);    <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span> + <span class="hljs-number">100px</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-variable">$var</span> * <span class="hljs-number">10%</span>;&#125;</code></pre><h3 id="3-嵌套"><a href="#3-嵌套" class="headerlink" title="3. 嵌套"></a>3. 嵌套</h3><p>&amp; ：父选择器</p><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;  <span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">color</span>: red;    <span class="hljs-selector-tag">header</span> &amp; &#123;      <span class="hljs-attribute">color</span>:green;      <span class="hljs-attribute">border</span>: &#123;      top: <span class="hljs-number">1px</span> solid red;      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">1px</span> solid green;      &#125;    &#125;  &#125;  &#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: green;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red;  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid green;&#125;</code></pre><pre><code class="hljs scss">伪类嵌套：&amp;和相连的类名之间不能有任何的空格,否则变为上述的后代选择器<span class="hljs-selector-class">.clearfix</span>&#123;    &amp;<span class="hljs-selector-pseudo">:before</span>,    &amp;<span class="hljs-selector-pseudo">:after</span> &#123;        <span class="hljs-attribute">content</span>:<span class="hljs-string">""</span>;        <span class="hljs-attribute">display</span>: table;    &#125;    &amp;<span class="hljs-selector-pseudo">:after</span> &#123;        <span class="hljs-attribute">clear</span>:both;        <span class="hljs-attribute">overflow</span>: hidden;    &#125;&#125;<span class="hljs-comment">// 编译后</span>clearfix<span class="hljs-selector-pseudo">:before</span>, <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;  <span class="hljs-attribute">display</span>: table;&#125;<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">overflow</span>: hidden;&#125;</code></pre><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><p>test：标准CSS注释，会有输出；test2：Sass注释，无输出；test3：压缩模式下也有输出</p><pre><code class="hljs sass">&#x2F;* test *&#x2F;&#x2F;&#x2F; test2&#x2F;*   test3*&#x2F;&#x2F;&#x2F; 编译后&#x2F;* test *&#x2F;&#x2F;*   test3*&#x2F;</code></pre><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h3><pre><code class="hljs scss"><span class="hljs-selector-class">.btn</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">10px</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.btn-primary</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f36</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-keyword">@extend</span> .btn;&#125;<span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">background-color</span>: orange;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-keyword">@extend</span> .btn;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-class">.btn</span>, <span class="hljs-selector-class">.btn-primary</span>, <span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">10px</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.btn-primary</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f36</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">background</span>-clor: orange;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;</code></pre><h3 id="6-Mixin"><a href="#6-Mixin" class="headerlink" title="6. Mixin"></a>6. Mixin</h3><p>@include调用@mixin</p><pre><code class="hljs scss"><span class="hljs-comment">// 无默认值</span><span class="hljs-keyword">@mixin</span> left &#123;<span class="hljs-attribute">float</span>: left;<span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123; <span class="hljs-keyword">@include</span> left; &#125;<span class="hljs-comment">// 有默认值，不传参就编译出默认值</span><span class="hljs-keyword">@mixin</span> left(<span class="hljs-variable">$value</span>: <span class="hljs-number">10px</span>) &#123;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-variable">$value</span>;&#125;<span class="hljs-selector-tag">div</span> &#123; <span class="hljs-keyword">@include</span> left(<span class="hljs-number">20px</span>); &#125;<span class="hljs-comment">// 组合用法</span><span class="hljs-keyword">@mixin</span> rounded(<span class="hljs-variable">$vert</span>, <span class="hljs-variable">$horz</span>, <span class="hljs-variable">$radius</span>: <span class="hljs-number">10px</span>) &#123;    <span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;-#&#123;<span class="hljs-variable">$horz</span>&#125;-radius: <span class="hljs-variable">$radius</span>;    -moz-<span class="hljs-attribute">border-radius</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;#&#123;<span class="hljs-variable">$horz</span>&#125;: <span class="hljs-variable">$radius</span>;    -webkit-<span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;-#&#123;<span class="hljs-variable">$horz</span>&#125;-radius: <span class="hljs-variable">$radius</span>;&#125;<span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-keyword">@include</span> rounded(top, left); &#125;<span class="hljs-selector-id">#footer</span> &#123; <span class="hljs-keyword">@include</span> rounded(top, left, <span class="hljs-number">5px</span>); &#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">float</span>: left;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">float</span>: left;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">10px</span>;  -moz-<span class="hljs-attribute">border-radius</span>-topleft: <span class="hljs-number">10px</span>;  -webkit-<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-id">#footer</span> &#123;  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">5px</span>;  -moz-<span class="hljs-attribute">border-radius</span>-topleft: <span class="hljs-number">5px</span>;  -webkit-<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">5px</span>;&#125;</code></pre><h3 id="7-import"><a href="#7-import" class="headerlink" title="7. @import"></a>7. @import</h3><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"path/filename.scss"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"foo.css"</span>;  <span class="hljs-comment">//</span></code></pre><h3 id="8-if-else"><a href="#8-if-else" class="headerlink" title="8. @if/@else"></a>8. @if/@else</h3><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">50%</span>;<span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-keyword">@if</span> <span class="hljs-variable">$a</span> &gt; <span class="hljs-number">30%</span> &#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125; <span class="hljs-keyword">@else</span> &#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;    &#125;&#125;</code></pre><h3 id="9-循环"><a href="#9-循环" class="headerlink" title="9. 循环"></a>9. 循环</h3><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from &lt;start&gt; through &lt;end&gt;  // 包括end<span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from &lt;start&gt; to &lt;end&gt;  // 不包括end<span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> to <span class="hljs-number">3</span> &#123;    <span class="hljs-selector-class">.border-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;        <span class="hljs-attribute">border</span>: #&#123;<span class="hljs-variable">$i</span>&#125;px solid blue;    &#125;&#125;<span class="hljs-variable">$i</span>: <span class="hljs-number">4</span>;<span class="hljs-keyword">@while</span> <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<span class="hljs-variable">$i</span>: <span class="hljs-variable">$i</span> - <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">@each</span> <span class="hljs-variable">$member</span> in a, b &#123;    .#&#123;<span class="hljs-variable">$member</span>&#125; &#123;    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/#&#123;$member&#125;.jpg"</span>);    &#125;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-class">.border-1</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;&#125;<span class="hljs-selector-class">.border-2</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;&#125;<span class="hljs-selector-class">.item-4</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">8em</span>;&#125;<span class="hljs-selector-class">.item-2</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>;&#125;<span class="hljs-selector-class">.a</span> &#123;  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/a.jpg"</span>);&#125;<span class="hljs-selector-class">.b</span> &#123;  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/b.jpg"</span>);&#125;</code></pre><h3 id="10-自定义函数"><a href="#10-自定义函数" class="headerlink" title="10. 自定义函数"></a>10. 自定义函数</h3><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> double(<span class="hljs-variable">$n</span>) &#123;    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$n</span> * <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-id">#sidebar</span> &#123;    <span class="hljs-attribute">width</span>: double(<span class="hljs-number">5px</span>);&#125;</code></pre><h3 id="11-media"><a href="#11-media" class="headerlink" title="11. @media"></a>11. @media</h3><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> screen &#123;  <span class="hljs-selector-class">.sidebar</span> &#123;    <span class="hljs-keyword">@media</span> (orientation: landscape) &#123;      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;    &#125;  &#125;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;  <span class="hljs-selector-class">.sidebar</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  &#125;&#125;</code></pre><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="https://github.com/lyanmm/front-end-note/blob/master/其他/sass.docx" target="_blank" rel="noopener">Sass笔记</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p><p><a href="https://sass-lang.com/" target="_blank" rel="noopener">https://sass-lang.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>应用层协议</title>
    <link href="/2020/07/05/HTTPandDNS/"/>
    <url>/2020/07/05/HTTPandDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="一、HTTP-HTTPS"><a href="#一、HTTP-HTTPS" class="headerlink" title="一、HTTP/HTTPS"></a>一、HTTP/HTTPS</h2><h3 id="1-概况"><a href="#1-概况" class="headerlink" title="1. 概况"></a>1. 概况</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。使用 TCP 作为传输层协议。HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p><h3 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h3><p>1）请求报文</p><p><img src="https://i.loli.net/2020/07/05/nU2BvTIfHsCER3V.png" srcset="/img/loading.gif" alt="request"></p><p>HTTP请求报文包括：请求行、请求头、空行 和 实体主体 。</p><p>请求行包含：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段：</p><ul><li>GET 方法只被用于向服务器获取数据。</li><li>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。</li><li>HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含响应体。</li><li>PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。</li></ul><p>请求方法更多表达的是语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看如何选择。更多方法可参看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">文档</a>。</p><p>2）响应报文</p><pre><code class="hljs angelscript">HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OKContent-Type: text/plainContent-Length: <span class="hljs-number">137582</span>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMTLast-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMTServer: Apache <span class="hljs-number">0.84</span>&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTTP 响应报文包括：状态行、响应头、空行 和 实体主体</p><p>状态行包含：协议版本字段、状态码 和 状态信息。</p><h3 id="3-请求-响应头"><a href="#3-请求-响应头" class="headerlink" title="3. 请求/响应头"></a>3. 请求/响应头</h3><p>有两种类型：请求首部、通用首部和实体首部；响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p><h3 id="4-HTTP版本"><a href="#4-HTTP版本" class="headerlink" title="4. HTTP版本"></a>4. HTTP版本</h3><p>HTTP/1.1：</p><ul><li>使用持久连接，多个请求可复用同一个 TCP 连接。</li><li>服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，容易造成排队的情况，称为“队头堵塞”。队头堵塞会导致持久连接在达到最大数量时，剩余的资源要等其他资源请求完后才能发起请求。为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。</li></ul><p>HTTP/2 ：</p><ul><li>彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。</li><li>每个请求或回应的所有数据包，称为一个数据流。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流，因为同一个连接里面连续的数据包，可能属于不同的请求。</li><li>引入了头信息压缩机制，头信息压缩后发送，并且客户端和服务器维护一张<u>头信息表</u>，所有字段都会存入这个表，生成一个<u>索引号</u>，以后就只发送索引号，提高速度。</li><li>允许服务器未经请求，主动向客户端推送静态资源，注意区别 WebSocket 等等。</li><li>因为用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，<u>遵守同一个</u>流量状态控制和拥塞控制。<u>只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去</u>。出现该问题是由于其使用 TCP 协议，与协议本身的实现其实没多大关系。</li></ul><p>HTTP/3 ：</p><ul><li>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能。</li></ul><h3 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5. 状态码"></a>5. 状态码</h3><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><h3 id="6-TLS-SSL-协议"><a href="#6-TLS-SSL-协议" class="headerlink" title="6. TLS/SSL 协议"></a>6. TLS/SSL 协议</h3><p>用于 HTTPS 的加密。</p><p>TLS 握手过程：</p><ol><li>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 值，用来供服务器检验。</li><li>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ol><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><p><a href="https://www.cnblogs.com/myseries/p/11239662.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11239662.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p><h2 id="二、DNS"><a href="#二、DNS" class="headerlink" title="二、DNS"></a>二、DNS</h2><h3 id="1-概况-1"><a href="#1-概况-1" class="headerlink" title="1. 概况"></a>1. 概况</h3><p>DNS 协议提供主机名到 IP 地址的转换服务，即Domain Name System，域名系统。DNS 协议运行在 <u>UDP 协议</u>之上，使用 <u>53 号</u>端口。</p><h3 id="2-层级结构"><a href="#2-层级结构" class="headerlink" title="2. 层级结构"></a>2. 层级结构</h3><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做 次级域名（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为 三级域名，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><pre><code class="hljs bash">主机名.次级域名.顶级域名.根域名<span class="hljs-comment"># 即</span>host.sld.tld.root</code></pre><h3 id="3-查询过程"><a href="#3-查询过程" class="headerlink" title="3. 查询过程"></a>3. 查询过程</h3><ol><li>将请求发送到本地 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求。</li><li>从“根域名服务器”查到“顶级域名服务器”的 NS(Name Server) 记录和 A 记录（ IP 地址）。</li><li>从“顶级域名服务器”查到“次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从“次级域名服务器”查出“主机名”的 IP 地址。</li></ol><p>一般我们<u>向本地 DNS 服务器发送请求的方式就是递归查询</u>，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而<u>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询</u>，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="4-DNS-记录和报文"><a href="#4-DNS-记录和报文" class="headerlink" title="4. DNS 记录和报文"></a>4. DNS 记录和报文</h3><p>DNS 服务器中以<u>资源记录</u>的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p>（<u>Name</u>，<u>Value</u>，<u>Type</u>，<u>TTL</u>）</p><p>其中 TTL （Time To Live）是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li>如果 Type = A，则 Name 是<u>主机名</u>，Value 是<u>主机名对应的 IP 地址</u>。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。</li><li>如果 Type = NS，则 Name 是个<u>域名</u>，Value 是<u>负责该域名的 DNS 服务器的主机名</u>。这个记录主要用于 DNS 链式查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type = CNAME，则 Name 为<u>别名</u>，Value 为<u>该主机的规范主机名</u>。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。</li><li>如果 Type = MX，则 Name 为<u>邮件服务器的别名</u>，Value 为<u>邮件服务器的规范主机名</u>。它的作用和 CNAME 是一样的，都是为了解决规范主机名不利于记忆的缺点。</li></ol><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/05/root-domain.html</a></p><h2 id="三、其他协议"><a href="#三、其他协议" class="headerlink" title="三、其他协议"></a>三、其他协议</h2><ol><li>文件传输协议(File Transfer Protocol，FTP)：用于实现交互式文件传输功能。</li><li>简单邮件传送协议(Simple Mail Transfer Protocol, SMTP)：用于实现电子邮箱传送功能。</li><li>简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。</li><li>远程登录协议(Telnet)：用于实现远程登录功能。</li><li>邮局协议版本3(Post Office Protocol - Version 3，POP3)：只下载邮件，服务器端并不删除。</li><li>交互邮件访问协议(Internet Mail Access Protocol，IMAP)：从邮件服务器上获取邮件的信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步请求</title>
    <link href="/2020/07/05/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/07/05/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><h2 id="一、异步"><a href="#一、异步" class="headerlink" title="一、异步"></a>一、异步</h2><p>JavaScript中主要有四种异步的实现方式。</p><h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h3><p>使用回调函数的缺点是，多个回调函数嵌套的时候会造成回调函数地狱，代码耦合度高，不利于代码维护。</p><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p>1）概念：</p><ul><li>Promise对象是一个构造函数，用来生成Promise实例。</li><li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</li><li>Promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li><li>Promise对象的状态改变，只有两种可能：从pending变为 fulfilled 和从pending变为 rejected 。要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。</li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 基本</span><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ... some code</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;    resolve(value);  &#125; <span class="hljs-keyword">else</span> &#123;    reject(error);  &#125;&#125;);<span class="hljs-comment">// 链式</span>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-comment">// success</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;  <span class="hljs-comment">// failure</span>&#125;);promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result));promise.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error));</code></pre><h3 id="3-Generator-函数"><a href="#3-Generator-函数" class="headerlink" title="3. Generator 函数"></a>3. Generator 函数</h3><p>1）概念：</p><ul><li><p>Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。</p></li><li><p>执行 Generator 函数会返回一个遍历器对象，可以是一个遍历器对象生成函数。</p></li><li><p>Generator.prototype.next()</p><p>返回一个由 yield表达式生成的值。</p><p>Generator.prototype.return()</p><p>返回给定的值并结束生成器。</p><p>Generator.prototype.throw()</p><p>向生成器抛出一个错误。</p></li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">helloWorldGenerator</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;  <span class="hljs-keyword">return</span> <span class="hljs-string">'ending'</span>;&#125;<span class="hljs-keyword">var</span> hw = helloWorldGenerator();hw.next()  <span class="hljs-comment">// &#123; value: 'hello', done: false &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: 'world', done: false &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: 'ending', done: true &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> helloWorldGenerator()) &#123;  <span class="hljs-built_in">console</span>.log(v);&#125;<span class="hljs-comment">// hello,world,ending</span></code></pre><h3 id="4-async-函数"><a href="#4-async-函数" class="headerlink" title="4. async 函数"></a>4. async 函数</h3><p>1）概念：</p><ul><li>本质上是是 Generator 函数的语法糖。</li><li>将 Generator 函数的星号（*）替换成async，将yield替换成await。</li><li>改进：拥有更好的语义，返回Promise对象，函数体内用 await 表示后面有需要等待的异步操作，await 还能接原始类型。</li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">interval</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    setTimeout(resolve, interval);  &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one2FiveInAsync</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-built_in">console</span>.log(i);    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);  &#125;&#125;one2FiveInAsync();<span class="hljs-comment">// 例二</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">url</span>) </span>&#123;  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();  <span class="hljs-keyword">return</span> html.match(<span class="hljs-regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-number">1</span>];&#125;getTitle(<span class="hljs-string">'https://tc39.github.io/ecma262/'</span>).then(<span class="hljs-built_in">console</span>.log)<span class="hljs-comment">// "ECMAScript 2017 Language Specification"</span></code></pre><h2 id="二、请求"><a href="#二、请求" class="headerlink" title="二、请求"></a>二、请求</h2><p>AJAX 即”Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。</p><h3 id="1-XMLHttpRequest"><a href="#1-XMLHttpRequest" class="headerlink" title="1. XMLHttpRequest"></a>1. XMLHttpRequest</h3><p>xhr.readyState</p><ul><li>0 - (未初始化)，还没有调用send()</li><li>1 - (载入)，已调用send()，正在发送请求</li><li>2 - (载入完成)，send()方法执行完成，已接收到全部的响应内容</li><li>3 - (交互)，正在解析响应内容</li><li>4 - (完成)，响应内容解析完成，可以在客户端调用</li></ul><p>xhr.status</p><ul><li>1xx - 指示信息，表示资源已经请求，继续处理</li><li>2xx - 表示成功处理请求，如200</li><li>3xx - 需要重定向，浏览器直接跳转<ul><li>301 - 永久重定向，每次访问A地址的时候，浏览器会自动跳到B地址</li><li>302 - 临时重新向，仅一次访问A地址时调到B，下次访问还是跳到A</li><li>304 - 资源未改变，若请求返回的资源与之前的相比没发生改变，服务器会返回304，浏览器会使用自己先前缓存的资源</li></ul></li><li>4xx - 客户端请求错误<ul><li>400 - 客户端请求有语法错误，不能被服务器端所理解</li><li>401 - 请求未经过授权，这个状态码必须和WWW-Authenticate报头域一起使用</li><li>403 - 服务器收到请求，但是拒绝提供该服务</li><li>404 - 请求的地址错误</li></ul></li><li>5xx - 服务端错误<ul><li>500 - 服务器发生不可预期的错误</li><li>503 - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul></li></ul><p>示例：</p><pre><code class="hljs js"><span class="hljs-comment">// 基本过程</span><span class="hljs-keyword">new</span> -&gt; open() -&gt; send(),设置监听函数，等待响应。<span class="hljs-comment">// get请求</span><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'./data/test.json'</span>, <span class="hljs-literal">true</span>)xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;      <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;xhr.send(<span class="hljs-literal">null</span>)<span class="hljs-comment">// post请求</span><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'/login'</span>, <span class="hljs-literal">true</span>)xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;      <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> postData = &#123;  name: <span class="hljs-string">'zhangsan'</span>,  password: <span class="hljs-string">'123'</span>&#125;xhr.send(<span class="hljs-built_in">JSON</span>.stringify(postData))</code></pre><h3 id="2-Fetch-API"><a href="#2-Fetch-API" class="headerlink" title="2. Fetch API"></a>2. Fetch API</h3><p>一个全局 API ，可用于发送请求，返回 Promise 对象。</p><p>注意：当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</p><pre><code class="hljs js">fetch(<span class="hljs-string">'http://example.com/movies.json'</span>,[&#123;options&#125;])  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-keyword">return</span> response.json();  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">myJson</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(myJson);  &#125;);</code></pre><h3 id="3-Axios"><a href="#3-Axios" class="headerlink" title="3. Axios"></a>3. Axios</h3><p>一个基于 promise 的 HTTP 库，可以用在浏览器和 Node.js 中。</p><p>$ npm install axios</p><p>主要方法：</p><p>axios.create([config])</p><p>axios.get(url[, config])</p><p>axios.post(url[, data[, config]])</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">let</span> instance = axios.create(&#123;  baseURL: <span class="hljs-string">'https://some-domain.com/api/'</span>    ...&#125;);<span class="hljs-comment">// 可以直接使用引入的对象发起请求</span>axios.get(<span class="hljs-string">'/user?ID=12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(error);  &#125;);<span class="hljs-comment">// 可以使用实例发起请求</span>instance.get(<span class="hljs-string">'/user?ID=12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)<span class="hljs-comment">// 其他请求方式同理</span>axios.post(<span class="hljs-string">'/user'</span>, &#123;    firstName: <span class="hljs-string">'Fred'</span>,    lastName: <span class="hljs-string">'Flintstone'</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(error);  &#125;);</code></pre><p>实际开发中会把函数设置为async，并在请求前加上await。</p><p>响应报文：</p><pre><code class="hljs js">&#123;  data: &#123;&#125;,  <span class="hljs-comment">// `data` 由服务器提供的响应</span>  status: <span class="hljs-number">200</span>,  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span>  statusText: <span class="hljs-string">'OK'</span>,  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>  headers: &#123;&#125;,  <span class="hljs-comment">// `headers` 服务器响应的头</span>  config: &#123;&#125;  <span class="hljs-comment">// `config` 是为请求提供的配置信息</span>&#125;axios.get(<span class="hljs-string">'/user/12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response.data);    <span class="hljs-built_in">console</span>.log(response.status);    <span class="hljs-built_in">console</span>.log(response.statusText);    <span class="hljs-built_in">console</span>.log(response.headers);    <span class="hljs-built_in">console</span>.log(response.config);  &#125;);</code></pre><h2 id="三、URI-URL"><a href="#三、URI-URL" class="headerlink" title="三、URI/URL"></a>三、URI/URL</h2><p>URI: Uniform Resource Identifier      指的是统一资源标识符<br>URL: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称</p><p>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</p><p>URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</p><pre><code class="hljs js"><span class="hljs-comment">// 假设当前url为： https://coding.imooc.com/lesson/115.html&amp;a=100#mid=30378</span><span class="hljs-built_in">console</span>.log(location.protocol)  <span class="hljs-comment">// 'https:'</span><span class="hljs-built_in">console</span>.log(location.host)      <span class="hljs-comment">// 'coding.imooc.com'</span><span class="hljs-built_in">console</span>.log(location.pathname)  <span class="hljs-comment">// '/lesson/115.html'</span><span class="hljs-built_in">console</span>.log(location.search)    <span class="hljs-comment">// '?a=100'</span><span class="hljs-built_in">console</span>.log(location.hash)      <span class="hljs-comment">// '#mid=30378'</span></code></pre><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API</a></p><p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></p><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对DOM和Virtual DOM的理解</title>
    <link href="/2020/07/05/DOMandVDOM/"/>
    <url>/2020/07/05/DOMandVDOM/</url>
    
    <content type="html"><![CDATA[<h1 id="对DOM和Virtual-DOM的理解"><a href="#对DOM和Virtual-DOM的理解" class="headerlink" title="对DOM和Virtual DOM的理解"></a>对DOM和Virtual DOM的理解</h1><h2 id="一、DOM"><a href="#一、DOM" class="headerlink" title="一、DOM"></a>一、DOM</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>MDN：文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。</p><p>理解：DOM就是对文档（HTML/XML）操作的接口。在DOM的概念里，将文档各种节点抽象成了一颗节点树（根节点是document），可以用各种接口对这颗树进行修改，从而改变文档所展示出来的结果。并不是说DOM是一颗节点树（DOM 是HTML和XML文档的编程接口），而是因为这些接口的存在，才把文档构建成了一颗树。</p><h3 id="2-DOM和JS的关系"><a href="#2-DOM和JS的关系" class="headerlink" title="2. DOM和JS的关系"></a>2. DOM和JS的关系</h3><ul><li><p>区别：DOM 跟编程语言（ JS 等等）是互相独立的，DOM译为文档对象模型，只是一种模型、结构，很多语言都能使用。</p></li><li><p>联系：DOM + JS 能组成一个web页面。</p></li></ul><h3 id="3-节点和节点树"><a href="#3-节点和节点树" class="headerlink" title="3. 节点和节点树"></a>3. 节点和节点树</h3><ol><li><p>DOM 的最小组成单位叫做节点（Node）。节点树/DOM树 就是由节点组成的。浏览器提供一个原生节点对象 Node ，所有的节点都继承自这个对象，拥有一些共同的属性和方法，这是 DOM 操作的基础。</p></li><li><p>注意区分 文档节点 和 文档元素 ：在HTML中，文档节点一般就是指根节点document，而文档元素就是指&lt;html&gt;元素，每个文档都只能有一个文档元素。</p></li><li><p>在HTML中，Node有7种类型：</p></li></ol><ul><li><code>Document</code>：整个文档树的顶层节点</li><li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li><li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li><li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li><li><code>Text</code>：标签之间或标签包含的文本</li><li><code>Comment</code>：注释</li><li><code>DocumentFragment</code>：文档的片段</li></ul><ol start="4"><li>Node原型上定义了许多的方法和属性，document节点也是继承自Node的，所以才能这样使用 document.querySelector 方法等等，还有获取 document.getElementsByTagName(‘html’)[0].nodeType 属性等等。</li><li>说白了就是用接口提供的Node对象上的方法和属性来修改和查看DOM树，来对页面修改。</li></ol><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><p><a href="http://luopq.com/2015/11/30/javascript-dom/" target="_blank" rel="noopener">http://luopq.com/2015/11/30/javascript-dom/</a></p><p><a href="https://wangdoc.com/javascript/dom/general.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/dom/general.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction</a></p><p>《JavaScript高级程序设计》（点击查看大图）</p><img src="https://i.loli.net/2020/07/05/a8vh347gnFr1BCf.png" srcset="/img/loading.gif" alt="image-20200705103854234" style="zoom:25%;" /><img src="https://i.loli.net/2020/07/05/iPYFSqKMwGOJQng.png" srcset="/img/loading.gif" alt="image-20200705103747825" style="zoom: 25%;" /><h2 id="二、Virtual-DOM"><a href="#二、Virtual-DOM" class="headerlink" title="二、Virtual DOM"></a>二、Virtual DOM</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>用 JS 模拟 DOM 结构，将 DOM 变化的对比放在 JS 层来做，实际上VDOM就是 JS 对象。</p><p>使用Virtual DOM ：render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></p><h3 id="2-为什么要用Virtual-DOM"><a href="#2-为什么要用Virtual-DOM" class="headerlink" title="2. 为什么要用Virtual DOM"></a>2. 为什么要用Virtual DOM</h3><ul><li>性能上直接操作真实 DOM 代价高</li><li>在框架中使用 VDOM 可以为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。</li></ul><h3 id="3-diff算法"><a href="#3-diff算法" class="headerlink" title="3. diff算法"></a>3. diff算法</h3><ul><li><p>最早用于解决LCS（最长公共子串）问题，找出两个序列之间的公共子序列。</p></li><li><p>在VDOM中使用传统diff算法，会跨级对比两个树之间的不同，时间复杂度为O(n<sup>3</sup>)。</p></li><li><p>在Vue中，diff 优化后只比较树的同层级，为O(n)。</p><p>实现方式：（这里只演示diff算法，具体的 VDOM 是如何更新的不演示）（在 diff 比较过程中，循环从两边向中间收拢）</p><p>1）首先列出新老节点比较的可能情况：</p><ul><li>当新老 VNode 节点的 start 满足 sameVnode 时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</li><li>当新老 VNode 节点的 end 满足 sameVnode 时，同样直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</li><li>当老 VNode 节点的 <u>start</u> 和新 VNode 节点的 <u>end</u> 满足 sameVnode 时，说明这次数据更新后 oldStartVnode 到了 oldEndVnode <u>后面</u>了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的<u>后面</u>，同时老 VNode 节点开始索引<u>加 1</u>，新 VNode 节点的结束索引<u>减 1</u>。</li><li>当老 VNode 节点的 <u>end</u> 和新 VNode 节点的 <u>start</u> 满足 sameVnode 时，这说明这次数据更新后 oldEndVnode 到了 oldStartVnode <u>前面</u>了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的<u>前面</u>，同时老 VNode 节点结束索引<u>减 1</u>，新 VNode 节点的开始索引<u>加 1</u>。</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用。这时候就找与newStartVnode 一致 <code>:key</code> 的旧的 VNode 节点，如果两者满足 sameVnode ，在进行 patchVnode 的同时会将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面；如果没有找到，就无法进行节点的复用，只能调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置。</li></ul><p>2）流程：</p><p>1、初始化：</p><img src="https://i.loli.net/2020/07/05/qKMmwChP9iHljBb.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>2、第一次循环：找到 旧节点末尾 和 新节点开头 (都是 D) 相同，复用 D 节点即可。同时旧节点的 endIndex 移动到了 C，新节点的 startIndex 移动到了 C。</p><img src="https://i.loli.net/2020/07/05/Yoc5FAqERtudwnI.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>3、第二次循环：同样是 旧节点末尾 和 新节点开头 (都是 C) 相同，于是创建 C 节点，插到D节点后。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E。（为什么第一次是复用，第二次是创建了？因为 old 序列队尾就是D直接复用即可）</p><img src="https://i.loli.net/2020/07/05/J2IpECfNtbUgmZL.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>4、第三次循环：发现 patchVnode 的 4 种情形都不符合，于是在旧节点队列中查找当前的新节点 E，不存在，只能创建新的节点 E，插入到 C 节点后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动。</p><img src="https://i.loli.net/2020/07/05/ROTXd9Fl5uM8bHj.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>5、第四次循环：新旧节点的开头 (都是 A) 相同，于是创建 A 节点，插入到 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B。</p><img src="https://i.loli.net/2020/07/05/T8b1y3QdwMEuCO6.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>6、第五次循环：同第四次循环，创建 B 节点插入到 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F。这时候发现新节点的 startIndex 已经大于 endIndex 了。不再满足循环的条件了，因此结束循环。</p><img src="https://i.loli.net/2020/07/05/iFwarlM67Pf9vLA.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>7、循环结束后，若 新节点数 大于 老节点数 则需要创建多出来的节点加入到队列中，反之删除。至此整个 diff 过程就已经全部完成了。在本例中，新节点数大于旧节点数，需要创建 newStartIdx 和 newEndIdx 之间的所有节点。在实例中就是 F 节点，因此创建 F 节点加入到 B 节点后即可。</p><img src="https://i.loli.net/2020/07/05/ouLQk1bpJKl7G8N.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /></li></ul><h3 id="4-参考-1"><a href="#4-参考-1" class="headerlink" title="4. 参考"></a>4. 参考</h3><p><a href="https://en.wikipedia.org/wiki/Diff" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Diff</a></p><p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></p><p><a href="https://www.zhihu.com/question/31809713" target="_blank" rel="noopener">https://www.zhihu.com/question/31809713</a></p><p><a href="https://www.zhihu.com/question/66851503" target="_blank" rel="noopener">https://www.zhihu.com/question/66851503</a></p><p><a href="https://juejin.im/post/5affd01551882542c83301da" target="_blank" rel="noopener">https://juejin.im/post/5affd01551882542c83301da</a></p><p><a href="https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f" target="_blank" rel="noopener">https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f</a></p><h2 id="三、感受"><a href="#三、感受" class="headerlink" title="三、感受"></a>三、感受</h2><p>diff算法算出来 O(n<sup>3</sup>) 真的看不懂，别人花了好几十年优化成 O(n<sup>3</sup>) ，待我水平够了再回看。这次重新复习 VDOM 让我对之前看Vue.js源码的理解有了更多更深的理解。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见Web攻击和防范</title>
    <link href="/2020/07/04/%E5%B8%B8%E8%A7%81Web%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E8%8C%83/"/>
    <url>/2020/07/04/%E5%B8%B8%E8%A7%81Web%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="常见Web攻击和防范"><a href="#常见Web攻击和防范" class="headerlink" title="常见Web攻击和防范"></a>常见Web攻击和防范</h1><h2 id="一、XSS-攻击和防范"><a href="#一、XSS-攻击和防范" class="headerlink" title="一、XSS 攻击和防范"></a>一、XSS 攻击和防范</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞注入恶意代码，在用户浏览器上运行，从而盗取用户的信息如 cookie 等。</p><h3 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h3><ul><li>存储型：恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</li><li>反射型：攻击者构建了特殊的 URL，当服务器接收到请求后，网站服务端将恶意代码从 URL 中取出，拼接到 HTML 后返回，浏览器接收后执行，从而导致了恶意代码的执行。</li><li>DOM 型：攻击者构建了特殊的 URL，用户打开带有恶意代码的 URL，浏览器接收到响应后解析执行，前端 JS 取出 URL 中的恶意代码并执行，从而导致了恶意代码的执行。</li></ul><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>DOM 型 XSS 跟前两种 XSS 的区别是：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="3-防范"><a href="#3-防范" class="headerlink" title="3. 防范"></a>3. 防范</h3><p>从上面的介绍可以知道预防 XSS 攻击有两个方面：恶意代码提交的时候 和 浏览器执行恶意代码的时候。</p><ol><li><p>前者：可分为两个过滤时机 前端过滤 和 后端过滤 </p><p>1）前端过滤：不可行，攻击者可绕过；</p><p>2）后端过滤：不可靠，当后端对存入数据库的数据都进行转义处理，再取出使用的时候，是不知道数据最后的使用场景的。</p></li><li><p>后者：可分为 纯前端渲染 和 对 HTML 做充分转义</p><p>1）纯前端渲染：回传的 HTML 不包含任何数据，数据通过 JS 请求得来，对 DOM 操作加载到页面上。但还需注意避免 DOM 型 XSS 漏洞。*</p><p>2）对 HTML 做充分转义：使用模板引擎，但不完善。</p><p>*DOM 型：网站前端 JavaScript 代码本身不够严谨，谨慎使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> ，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p></li></ol><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h3><ol><li><p>CSP ：通过指定有效域即只执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</p></li><li><p>使用js-xss库：<a href="http://jsxss.com" target="_blank" rel="noopener">http://jsxss.com</a></p></li><li><p>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</p></li><li><p>验证码：防止脚本冒充用户提交危险操作。</p></li><li><p>对于不受信任的输入，都应该限定一个合理的长度。</p></li></ol><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">https://juejin.im/post/5bad9140e51d450e935c6d64</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p><p><a href="https://allenxz.github.io/2019/11/17/safety" target="_blank" rel="noopener">https://allenxz.github.io/2019/11/17/safety</a></p><h2 id="二、XSRF-CSRF-攻击和防范"><a href="#二、XSRF-CSRF-攻击和防范" class="headerlink" title="二、XSRF/CSRF 攻击和防范"></a>二、XSRF/CSRF 攻击和防范</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><ul><li><a href="http://xn--a-f38al5vkzdt61bv7l.com" target="_blank" rel="noopener">受害者登录a.com</a>，并保留了登录凭证（Cookie）。</li><li><a href="http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com" target="_blank" rel="noopener">攻击者引诱受害者访问了b.com</a>。</li><li><a href="http://b.com" target="_blank" rel="noopener">b.com</a> 向 <a href="http://a.com" target="_blank" rel="noopener">a.com</a> 发送了一个请求：<a href="http://a.com/act=xx。浏览器会默认携带a.com的Cookie。" target="_blank" rel="noopener">http://a.com/act=xx。浏览器会默认携带a.com的Cookie。</a></li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ul><h3 id="2-类型-1"><a href="#2-类型-1" class="headerlink" title="2. 类型"></a>2. 类型</h3><ul><li>GET类型的CSRF：&lt;img&gt;标签scr属性发起一个get请求。</li><li>POST类型的CSRF：攻击者伪造一个隐藏的表单，访问网页后自动发起post请求。</li><li>链接类型的CSRF：诱导点击。</li></ul><h3 id="3-防范-1"><a href="#3-防范-1" class="headerlink" title="3. 防范"></a>3. 防范</h3><p>从上面的介绍可以知道预防 CSRF 攻击有两个方面：阻止不明外域的访问 和 请求时附加特定信息。</p><ol><li><p>前者：</p><p>1）同源检测：在浏览器发起请求时，大多会自动带上Origin Header和Referer Header，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域；如果Origin和Referer都不存在，建议直接进行阻止。</p><p>2）Samesite Cookie属性：Set-Cookie的属性，分为 Strict 和 Lax。严格模式下Cookie 不可作为第三方 Cookie；宽松模式下假如有请求改变了当前页面或者打开新页面且同时是个GET请求，就可作为第三方 Cookie。</p></li></ol><pre><code class="hljs html">Set-Cookie: foo=1; Samesite=Strict Set-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3实例：假如淘宝网用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</code></pre><ol start="2"><li><p>后者：</p><p>1）CSRF Token：根据攻击者只会冒用Cookie的特征，服务器就要求所有用户请求时携带攻击者无法获取到的Token，由服务器随机生成。</p><p>2）双重Cookie认证：根据攻击者只会冒用Cookie的特征，服务器要求所有用户请求时携带一个Cookie中的值，这个值会在服务器随机生成，并在响应头给出。</p></li></ol><h3 id="4-补充-1"><a href="#4-补充-1" class="headerlink" title="4. 补充"></a>4. 补充</h3><ol><li>验证码、手机短信等都可以起到CSRF Token的作用，而且更安全。</li><li>使用CSRFTester。</li></ol><h3 id="5-参考-1"><a href="#5-参考-1" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener">https://juejin.im/post/5bc009996fb9a05d0a055192</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie</a></p><h2 id="三、感受"><a href="#三、感受" class="headerlink" title="三、感受"></a>三、感受</h2><p>看了很多资料，个人认为攻防方式只能互相对应，实际生产中会用各种各样的方式来保证信息安全，降低风险，但不可能完全消除风险。</p><p>更多的安全知识有待继续探究。</p><p><a href="https://www.v2ex.com/t/516357" target="_blank" rel="noopener">https://www.v2ex.com/t/516357</a></p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同源策略和跨域方案</title>
    <link href="/2020/07/04/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/04/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略和跨域方案"><a href="#同源策略和跨域方案" class="headerlink" title="同源策略和跨域方案"></a>同源策略和跨域方案</h1><h2 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/port" target="_blank" rel="noopener">port</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/host" target="_blank" rel="noopener">host</a> 都相同的话，则这两个 URL 是同源。</p><h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><img src="https://i.loli.net/2020/07/04/oF94YraAtjB8c3X.png" srcset="/img/loading.gif" alt="image-20200704114257308" style="zoom:80%;" /><h3 id="3、参考"><a href="#3、参考" class="headerlink" title="3、参考"></a>3、参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><h2 id="二、跨域方案"><a href="#二、跨域方案" class="headerlink" title="二、跨域方案"></a>二、跨域方案</h2><h3 id="1、JSONP"><a href="#1、JSONP" class="headerlink" title="1、JSONP"></a>1、JSONP</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url, params, callback</span>) </span>&#123;  <span class="hljs-comment">// 判断是否含有参数</span>  <span class="hljs-keyword">let</span> queryString = url.indexOf(<span class="hljs-string">"?"</span>) === <span class="hljs-string">"-1"</span> ? <span class="hljs-string">"?"</span> : <span class="hljs-string">"&amp;"</span>;  <span class="hljs-comment">// 添加参数</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> params) &#123;    <span class="hljs-keyword">if</span> (params.hasOwnProperty(k)) &#123;      queryString += k + <span class="hljs-string">"="</span> + params[k] + <span class="hljs-string">"&amp;"</span>;    &#125;  &#125;  <span class="hljs-comment">// 处理回调函数名</span>  <span class="hljs-keyword">let</span> random = <span class="hljs-built_in">Math</span>.random()      .toString()      .replace(<span class="hljs-string">"."</span>, <span class="hljs-string">""</span>),    callbackName = <span class="hljs-string">"myJsonp"</span> + random;  <span class="hljs-comment">// 添加回调函数</span>  queryString += <span class="hljs-string">"callback="</span> + callbackName;  <span class="hljs-comment">// 构建请求</span>  <span class="hljs-keyword">let</span> scriptNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);  scriptNode.src = url + queryString;  <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 调用回调函数</span>    callback(...arguments);    <span class="hljs-comment">// 删除这个引入的脚本</span>    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].removeChild(scriptNode);  &#125;;  <span class="hljs-comment">// 发起请求</span>  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].appendChild(scriptNode);&#125;</code></pre><h3 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h3><ol><li><p>总概：在向服务器发送请求的时候，加上一些特定的头部信息，并配置服务器，让服务器放行该种请求，返回资源。</p></li><li><p>示例：</p><p>请求报文：</p></li></ol><pre><code class="hljs shell">Origin: http://foo.example</code></pre><p>​        响应报文：</p><pre><code class="hljs shell">Access-Control-Allow-Origin: *</code></pre><ol start="3"><li>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li></ol><h3 id="3、Vue-js中使用代理"><a href="#3、Vue-js中使用代理" class="headerlink" title="3、Vue.js中使用代理"></a>3、Vue.js中使用代理</h3><ol><li>实现：</li></ol><pre><code class="hljs js"><span class="hljs-comment">// vue.config.js</span>devServer: &#123;    proxy: &#123;  <span class="hljs-comment">//配置跨域</span>      <span class="hljs-string">'/api'</span>: &#123;        target: <span class="hljs-string">'http://121.121.67.254:8185/'</span>,  <span class="hljs-comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span>        changOrigin: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//允许跨域</span>        pathRewrite: &#123;          <span class="hljs-comment">/* 重写路径，当我们在浏览器中看到请求的地址为：</span><span class="hljs-comment">          http://localhost:8080/api/core/getData/userInfo 时，</span><span class="hljs-comment">          实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api */</span>          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span>         &#125;      &#125;,    &#125;  &#125;,</code></pre><ol start="2"><li>补充：这种方法只适合于开发阶段，工程尚未编译的时候使用，仅作为一个方便调用接口的解决方案。</li><li>参考：<a href="https://www.cnblogs.com/lihaohua/p/12372267.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihaohua/p/12372267.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用图床为md插入图片</title>
    <link href="/2020/07/04/%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%E4%B8%BAmd%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2020/07/04/%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%E4%B8%BAmd%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用图床为md插入图片"><a href="#使用图床为md插入图片" class="headerlink" title="使用图床为md插入图片"></a>使用图床为md插入图片</h1><h2 id="一、背景原因"><a href="#一、背景原因" class="headerlink" title="一、背景原因"></a>一、背景原因</h2><p>在之前的那篇Hexo搭建的博文中提到使用<code>post_asset_folder: true</code>来处理md中的图片资源。虽然有考虑过在国内使用GitHub的体验很差，图片加载速度慢，但相比于图床的工作量，还是觉得图床使用不方便，但现在新发现了一个非常方便的方法。</p><h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><ol><li><p>下载并安装 Typora ：<a href="https://www.typora.io/#download" target="_blank" rel="noopener">https://www.typora.io/#download</a></p><p>暂时只知道 Typora 有该功能。</p></li><li><p>下载并安装 PicGo ：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p><p>最低使用 2.3.0 版本（ beta 版本亦可）</p></li><li><p>注册图床帐号：<a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p></li><li><p>在图床后台生成 token ：</p><p>sm.ms首页-&gt;User-&gt;Dashboard-&gt;API Token-&gt;Generate Secret Token-&gt;选中、右键、复制 Secret Token</p></li><li><p>为 PicGo 添加Token：</p><p>打开PicGo-&gt;左侧图床设置-&gt;SM.MS图床-&gt;粘贴刚刚复制的Token</p></li><li><p>连接 Typora 和 PicGo ：</p><p>打开Typora-&gt; 左上角”文件”-&gt;使用偏好-&gt;左侧图像-&gt;按照下方图片设置各个选项</p><img src="https://i.loli.net/2020/07/04/W5rX1PiQIEZKSlo.png" srcset="/img/loading.gif" alt="image-20200704111446575" style="zoom:67%;" /></li><li><p>完成：</p><p>按照这些步骤完成设置之后，就可以直接在Typora 里粘贴任何地方的图片了，然后Typora 会自动把图片上传到你的图床帐号上，并且自动插入图片。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面性能优化</title>
    <link href="/2020/07/03/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2020/07/03/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h1><h2 id="一、页面加载过程"><a href="#一、页面加载过程" class="headerlink" title="一、页面加载过程"></a>一、页面加载过程</h2><ul><li><p>加载</p><ol><li>DNS解析：域名 -&gt; IP地址；</li><li>取得目的主机 MAC 地址；</li><li>浏览器与目的IP地址建立TCP连接，发起Http请求；</li><li>服务器处理请求，返回资源。</li></ol></li><li><p>渲染</p><ol><li>解析 HTML 代码构建 DOM 树，解析 CSS 代码构建 CSSOM 规则树；</li><li>根据 DOM 和 CSSOM 构建 Render Tree  ；</li><li>利用 Render Tree 对页面进行布局和绘制；</li><li>在解析 HTML 代码时，遇到&lt;script&gt; 浏览器会先下载和构建CSSOM，然后执行脚本，最后才是继续构建DOM。</li></ol></li></ul><h2 id="二、优化方向与方法"><a href="#二、优化方向与方法" class="headerlink" title="二、优化方向与方法"></a>二、优化方向与方法</h2><p>1、总体方向：</p><ul><li><p>加快加载速度：</p><p>压缩代码，减少体积；</p><p>减少请求数；</p><p>使用 CDN 加速；</p><p>使用 SSR （服务器端渲染）。</p></li><li><p>加快渲染速度：</p><p>CSS放在 head 标签内，JS放在 body 最后；*</p><p>尽早开始执行JS，用 DOMContentLoaded 触发；**</p><p>懒加载；</p><p>缓存 DOM 查询操作，将对 DOM 的操作合并，最后再操作改变 DOM； </p><p>节流（throttle）、防抖（debounce）。</p></li></ul><p>*  前者是为了防止渲染过程中Render Tree发生改变重新渲染；后者是为了让页面尽快呈现出来，减少用户等待时间；</p><p>**  window.onload：等页面全部资源加载完才会执行，包括视频、图片;</p><p>​      DOMContentLoaded： DOM渲染完成后就能执行，此时图片、视频等可能为加载完成4。</p><p>2、实现方法：</p><ol><li><p>SSR ： 可以使用 Nuxt.js 做 SSR</p></li><li><p>懒加载：</p><p>方法一：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"img"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"preview.png"</span> <span class="hljs-attr">data-realsrc</span>=<span class="hljs-string">"abc.png"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'img'</span>).length;</span><span class="javascript">    <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"img"</span>);</span><span class="actionscript">    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><span class="actionscript">    lazyload(); <span class="hljs-comment">//页面载入完毕加载可是区域内的图片</span></span><span class="javascript">    <span class="hljs-built_in">window</span>.onscroll = lazyload;</span><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//监听页面滚动事件</span></span><span class="javascript">        <span class="hljs-keyword">var</span> seeHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">//可见区域高度</span></span><span class="javascript">        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop; <span class="hljs-comment">//滚动条距离顶部高度</span></span><span class="actionscript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; num; i++) &#123;</span>            if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;<span class="actionscript">                <span class="hljs-keyword">if</span> (img[i].getAttribute(<span class="hljs-string">"src"</span>) == <span class="hljs-string">"default.jpg"</span>) &#123;</span><span class="actionscript">                    img[i].src = img[i].getAttribute(<span class="hljs-string">"data-src"</span>);</span>                &#125;                n = i + 1;            &#125;        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>方法二：<a href="https://juejin.im/post/5bbc60e8f265da0af609cd04" target="_blank" rel="noopener">https://juejin.im/post/5bbc60e8f265da0af609cd04</a></p></li><li><p>节流（throttle）：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数节流的实现;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;  <span class="hljs-keyword">var</span> preTime = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>,      args = <span class="hljs-built_in">arguments</span>,      nowTime = <span class="hljs-built_in">Date</span>.now();    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;      preTime = <span class="hljs-built_in">Date</span>.now();      <span class="hljs-keyword">return</span> fn.apply(context, args);    &#125;  &#125;;&#125;<span class="hljs-comment">// 业务实例：拖拽一个元素，要随时拿到该元素被拖拽的位置。</span><span class="hljs-comment">// 直接用drag事件，则会频发的触发，很容易导致卡顿。</span><span class="hljs-comment">// 而节流则是无论比拖拽多快，都会每隔一个固定事件触发一次。</span><span class="hljs-keyword">const</span> div1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'div1'</span>)div1.addEventListener(<span class="hljs-string">'drag'</span>, throttle( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(e.offsetX, e.offsetY)&#125;, <span class="hljs-number">200</span>))</code></pre></li><li><p>防抖（debounce）：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数防抖的实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>,      args = <span class="hljs-built_in">arguments</span>;    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span>    <span class="hljs-keyword">if</span> (timer) &#123;      clearTimeout(timer);      timer = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      fn.apply(context, args);    &#125;, wait);  &#125;;&#125;<span class="hljs-comment">// 业务实例：监听一个输入框的文字变化后，触发change事件。</span><span class="hljs-comment">// 直接用keyup事件，会频繁的触发change事件。</span><span class="hljs-comment">// 而防抖则是用户输入结束或者暂停时，才会触发change事件。</span><span class="hljs-keyword">const</span> input1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input1'</span>)input1.addEventListener(<span class="hljs-string">'keyup'</span>, debounce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(input1.value)&#125;))</code></pre></li></ol><h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><ol><li><p>DNS 预解析：使浏览器主动去执行域名解析。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//example.com"</span>&gt;</span></code></pre></li><li><p>HTTP预连接：</p><p>解释href的属性值，如果是合法的URL，然后继续判断URL的协议是否是http或者https否则就结束处理。</p><p>如果当前页面host不同于href属性中的host，crossorigin其实被设置为anonymous(就是不带cookie了)，如果希望带上cookie等信息可以加上crossorign属性，corssorign就等同于设置为use-credentials</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//example.com"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//cdn.example.com"</span> <span class="hljs-attr">crossorigin</span>&gt;</span></code></pre></li><li><p>预加载资源：让浏览器预加载一个资源（HTML，JS，CSS或者图片等），但页面是不会解析或者JS是不会直接执行的。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//example.com/next-page.html"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"html"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"use-credentials"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/library.js"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"script"</span>&gt;</span></code></pre></li><li><p>预渲染：不仅会加载资源，还会解执行页面，进行预渲染，但是这都是根据浏览器自身进行判断。</p><ul><li>分配少量资源对页面进行预渲染。</li></ul><ul><li>挂起部分请求直至页面可见时。</li><li>可能会放弃预渲染，如果消耗资源过多。</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"prerender"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//example.com/next-page.html"</span>&gt;</span></code></pre></li><li><p>pr属性：</p><p>dns-prefetch，preconnect，prefetch和prerender都支持一个pr属性（0.0到1.0范围的值），让浏览器能够判断优先加载哪些资源。浏览器内部是有可用的连接池的，资源紧张的情况下只能加载优先级更高的资源。</p></li><li><p>浏览器缓存：<a href="https://lyanmm.github.io/2020/07/20/浏览器缓存/" target="_blank" rel="noopener">链接</a></p></li></ol><p>参考：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes</a></p><p><a href="https://segmentfault.com/a/1190000011065339" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011065339</a></p><p><a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="noopener">https://github.com/joshbuchea/HEAD</a></p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建</title>
    <link href="/2020/07/03/Hexo%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/07/03/Hexo%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><ol><li><p>安装Node.js</p></li><li><p>换源</p><p><a href="https://www.jianshu.com/p/4aaf929bfa71" target="_blank" rel="noopener">https://www.jianshu.com/p/4aaf929bfa71</a></p><p>1）方法一：npm i -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>2）方法二：npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></li><li><p>安装hexo</p><p>npm i -g hexo-cli</p></li><li><p>在任意位置创建一个空目录来存放所有有关博客的东西</p><p>~/blog</p></li><li><p>初始化博客</p><p>hexo init</p></li><li><p>启动博客</p><p>hexo s</p></li></ol><h2 id="二、生成一篇博文"><a href="#二、生成一篇博文" class="headerlink" title="二、生成一篇博文"></a>二、生成一篇博文</h2><ol><li><p>生成一篇博文</p><p>hexo new post &lt;title&gt;</p></li><li><p>清理缓存</p><p>hexo clean</p></li><li><p>重新生成静态文件</p><p>hexo g</p></li><li><p>重新启动查看新建的博文（非必须）</p><p>hexo s</p></li></ol><h2 id="三、部署到GitHub上"><a href="#三、部署到GitHub上" class="headerlink" title="三、部署到GitHub上"></a>三、部署到GitHub上</h2><ol><li><p>创建一个新的仓库</p><p>仓库名：[username].github.io</p><p>ps. 仓库名必须为[username].github.io</p></li><li><p>在blog目录下安装git部署插件</p><p>目录：~/blog</p><p>命令：npm i -S hexo-deployer-git</p></li><li><p>配置 _config.yml</p><p>目录：~/blog</p><p>更改后：</p><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/lyanmm/lyanmm.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>部署到远端</p><p>hexo d</p></li><li><p>查看</p><p>https://[username].github.io/</p></li></ol><h2 id="四、后续发表的博文"><a href="#四、后续发表的博文" class="headerlink" title="四、后续发表的博文"></a>四、后续发表的博文</h2><ol><li><p>生成一篇博文</p><p>hexo new post &lt;title&gt;</p></li><li><p>清理缓存</p><p>hexo clean</p></li><li><p>重新生成静态文件</p><p>hexo g</p></li><li><p>部署到远端</p><p>hexo d</p></li></ol><h2 id="五、其他配置"><a href="#五、其他配置" class="headerlink" title="五、其他配置"></a>五、其他配置</h2><h3 id="1、更换主题"><a href="#1、更换主题" class="headerlink" title="1、更换主题"></a>1、更换主题</h3><p>可在GitHub上搜索主题</p><p>关键词：  hexo-theme-</p><h3 id="2、为md引入静态资源"><a href="#2、为md引入静态资源" class="headerlink" title="2、为md引入静态资源"></a>2、为md引入静态资源</h3><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p><h3 id="3、处理md中的图片资源"><a href="#3、处理md中的图片资源" class="headerlink" title="3、处理md中的图片资源"></a>3、处理md中的图片资源</h3><p>在网上搜寻一番都没有找到合适的方法，如果用图床则工作量太大，要逐个上传，后来自己慢慢摸索下发现这个方法可用。</p><ol><li><p>在 _config.yml 中修改：</p><p>post_asset_folder: true</p></li><li><p>引用：</p><p>new一篇博文后会生成一个 &lt;title&gt; 文件夹和 &lt;title&gt; .md 文件</p><p>将图片放入 &lt;title&gt; 文件夹中，</p><p>在md中直接插入img链接：&lt;img src=”[finename]” alt=”” style=”” /&gt;。</p></li></ol><p>这样的好处是可以通过修改img的style来调整大小，但也有一个缺点，就是md在本地是看不到图片的。</p><p>解决方法：在另外的地方正常写好md，全选复制到 new 出来的 md 中，然后将img标签 src 里前面一串路径删去留下文件名即可。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>碎语</title>
    <link href="/2020/07/02/%E7%A2%8E%E8%AF%AD/"/>
    <url>/2020/07/02/%E7%A2%8E%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="博客的由来"><a href="#博客的由来" class="headerlink" title="博客的由来"></a>博客的由来</h1><p>其实早就想写一个博客来记录平时的笔记等等，但是一直没有那个让我动手的、一瞬间的冲动。直到今晚，我在看一个视频的时候，UP主提到了写博客的事情，他之前也录了很多期搭博客的视频。上周还没考完期末考的时候我就在想，考完期末之后如果找不到实习，那就抽点时间出来写一下吧。这两天考完试也是尝试着投了几家，但暂时都没有回应。刚好晚上也比较困，不想继续复习了，于是就动手了。</p><h1 id="搭建感受"><a href="#搭建感受" class="headerlink" title="搭建感受"></a>搭建感受</h1><p>具体的搭建过程我已经写了另外的一篇，这里简单谈谈搭的时候的感受吧。我开始以为自己搭一个会很难，但其实都有现成的框架、主题、插件等等，整个过程还是挺顺利的，没有想象中的难。我本来下了很多主题想折腾一番的哈哈，最后还是只选了一个Material Design的主题。我个人还是挺喜欢Material Design，虽然现在谷歌好像很少提及了。但它当时出现的时候，我一眼就喜欢上这种风格了，鲜明有特色。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为最早开始学前端的时候，并没有想过把学习笔记放到博客上，所以都是用的Word记录，当时也不知道有Markdown这种文件格式，所以就没办法把早期的资料发布了。后来会用 md 了，记录的一些笔记，格式也没有调好，很多在本地看是正常的，但是发布之后格式就乱了。没办法，只能从现在开始注意好格式，把笔记写漂亮点。</p>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器存储方式</title>
    <link href="/2020/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><p>通过 document.cookie = ‘….’ 操作。</p><p>cookie的缺点：</p><ul><li>有大小限制，最大4KB</li><li>http请求时需要发送到服务端，增加请求数据量</li></ul><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a></p><h2 id="二、Web-Storage-API"><a href="#二、Web-Storage-API" class="headerlink" title="二、Web Storage API"></a>二、Web Storage API</h2><p>Web Storage 包含如下两种机制：</p><ul><li>sessionStorage： 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li><li>localStorage： 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</li><li>这两个有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，才可以随意存取，在A域名存，B域名下取不出。</li></ul><pre><code class="hljs js"><span class="hljs-comment">// 保存数据</span>sessionStorage.setItem(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);localStorage.setItem(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);<span class="hljs-comment">// 获取数据</span><span class="hljs-keyword">let</span> sData = sessionStorage.getItem(<span class="hljs-string">'key'</span>);<span class="hljs-keyword">let</span> lData = localStorage.getItem(<span class="hljs-string">'key'</span>);<span class="hljs-comment">// 删除保存的数据</span>sessionStorage.removeItem(<span class="hljs-string">'key'</span>);localStorage.removeItem(<span class="hljs-string">'key'</span>);<span class="hljs-comment">// 删除所有保存的数据</span>sessionStorage.clear();localStorage.clear();</code></pre><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到页面呈现</title>
    <link href="/2020/06/23/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/"/>
    <url>/2020/06/23/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="从输入URL到页面呈现"><a href="#从输入URL到页面呈现" class="headerlink" title="从输入URL到页面呈现"></a>从输入URL到页面呈现</h1><p>这是一个宽泛的命题，仅记录主要步骤。</p><ul><li>分析URL合法性，构造请求</li><li>查找强缓存</li><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP/HTTPS 请求</li><li>页面渲染</li><li>视情况关闭 TCP 连接</li></ul><h2 id="一、分析URL合法性，构造请求"><a href="#一、分析URL合法性，构造请求" class="headerlink" title="一、分析URL合法性，构造请求"></a>一、分析URL合法性，构造请求</h2><p>浏览器会检查URL，不正常的URL会显示错误页面或者直接使用搜索引擎搜索，合法的URL会正常构造一个请求。</p><h2 id="二、查找强缓存"><a href="#二、查找强缓存" class="headerlink" title="二、查找强缓存"></a>二、查找强缓存</h2><p>浏览器直接先在本地缓存找是否有资源。</p><p>强缓存详见<a href="https://lyanmm.github.io/2020/07/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">链接</a>。</p><h2 id="三、DNS-解析"><a href="#三、DNS-解析" class="headerlink" title="三、DNS 解析"></a>三、DNS 解析</h2><ol><li>将请求发送到本地 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求。</li><li>从“根域名服务器”查到“顶级域名服务器”的 NS(Name Server) 记录和 A 记录（ IP 地址）。</li><li>从“顶级域名服务器”查到“次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从“次级域名服务器”查出“主机名”的 IP 地址。</li></ol><p>向本地 DNS 服务器发送请求的方式就是递归查询，因为只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h2 id="四、TCP-连接"><a href="#四、TCP-连接" class="headerlink" title="四、TCP 连接"></a>四、TCP 连接</h2><p>第一次握手，<u>客户端向服务器发送</u>一个 SYN 报文段，SYN 置为1，<u>序号字段</u> seq 是一个随机数。</p><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后<u>向客户端发送</u> SYN ACK 报文段，SYN 和 ACK 置为 1，还有序号字段是服务器端产生的一个随机数。<u>确认号字段</u>为客户端发送的序号加一。</p><p>第三次握手，客户端接收响应后，也会为这次 TCP 连接分配缓存和变量，同时<u>向服务器端发送</u> ACK 报文段，ACK 置为1，序号字段为第二次握手时的确认号，确认后字段为第二次握手时的序号。第三次握手可以在报文段中携带数据。</p><img src="https://i.loli.net/2020/07/25/ryjXDpOBJKxmtu1.png" srcset="/img/loading.gif" alt="image-20200622151722927" style="zoom:67%;" /><h2 id="五、发送请求"><a href="#五、发送请求" class="headerlink" title="五、发送请求"></a>五、发送请求</h2><p>请求行、请求头和请求体。</p><p>详见<a href="[https://lyanmm.github.io/2020/07/05/HTTPandDNS/#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE](https://lyanmm.github.io/2020/07/05/HTTPandDNS/#应用层协议)">链接</a>。</p><p>如果是HTTPS，则要经过TLS加密：</p><ol><li><p>第一步，客户端向服务器发起请求，请求中包含使用的<u>协议版本号</u>、生成的一个<u>随机数</u>、以及客户端支持的<u>加密方法</u>。</p></li><li><p>第二步，服务器端接收到请求后，确认双方使用的<u>加密方法</u>、并给出服务器的<u>证书</u>、以及一个服务器生成的<u>随机数</u>。</p></li><li><p>第三步，客户端确认服务器证书有效后，<u>生成一个新的随机数</u>，并使用数字证书中的公钥，<u>加密这个随机数</u>，然后发给服务器。并且还会提供一个前面所有内容的 <u>hash 值</u>，用来供服务器检验。</p></li><li><p>第四步，服务器使用自己的私钥，来<u>解密</u>客户端发送过来的随机数。并提供前面所有内容的 <u>hash 值</u>来供客户端检验。</p></li><li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成<u>对话秘钥</u>，以后的对话过程都使用这个秘钥来加密信息。</p></li></ol><h2 id="六、页面渲染"><a href="#六、页面渲染" class="headerlink" title="六、页面渲染"></a>六、页面渲染</h2><ul><li>解析 HTML 代码构建 DOM 树，解析 CSS 代码构建 CSSOM 规则树；</li><li>根据 DOM 和 CSSOM 构建 Render Tree ；</li><li>利用 Render Tree 对页面进行布局和绘制，最后显示；</li></ul><p>关于阻塞：在解析 HTML 代码时，遇到 &lt;script&gt; 浏览器会先下载和构建CSSOM，然后执行脚本，最后才是继续构建DOM。</p><p>defer 和 async的<a href="https://lyanmm.github.io/2020/07/18/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A0%87%E7%AD%BE%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD/#2%E3%80%81script%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">区别</a>。</p><h2 id="七、关闭TCP连接"><a href="#七、关闭TCP连接" class="headerlink" title="七、关闭TCP连接"></a>七、关闭TCP连接</h2><p>如果请求头或响应头中包含Connection: Keep-Alive，表示建立持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接，否则断开TCP连接。</p><p>第一次挥手，<u>客户端向服务器</u>发送一个 FIN 报文段，申请断开连接，FIN 置为1，序列号字段是一个随机数。发送后客户端进入 FIN_WAIT_1 状态。</p><p>第二次挥手，服务器端接收到请求后，<u>向客户端发送</u> ACK 报文段，序列号字段是一个新的随机数，确认号字段是第一次挥手时序列号加1。因为连接是全双工的，所以此时<u>服务器端还可以向客户端发送数据</u>。服务器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p><p>第三次挥手，服务器端发送完所有数据后，<u>向客户端发送</u> FIN ACK 报文段，序列号字段是一个新的随机数，确认号字段与第二次挥手时一样。发送后进入 LAST_ACK 状态。</p><p>第四次挥手，<u>客户端向服务器端</u>发送 ACK 报文段，序列号字段是第三次挥手时的确认号，确认号字段是第三次挥手时的序列号加1，并进入 TIME_WAIT 阶段。该阶段会持续2MSL，即该报文段在网络中的最大生存时间。如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态；如果收到服务器的重发请求就重新发送 ACK 报文段。服务器端收 ACK 报文段后就进入 CLOSED 状态。</p><img src="https://i.loli.net/2020/07/25/3voCEi18Dn7xaIm.png" srcset="/img/loading.gif" alt="image-20200622152454502" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码笔记</title>
    <link href="/2020/04/29/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/29/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="vue源码笔记"><a href="#vue源码笔记" class="headerlink" title="vue源码笔记"></a>vue源码笔记</h1><p>以下所有路径的 * = node_modules/vue</p><h2 id="零、生命周期图"><a href="#零、生命周期图" class="headerlink" title="零、生命周期图"></a>零、生命周期图</h2><img src="image-20200429093329909.png" srcset="/img/loading.gif" alt="image-20200429093329909" style="zoom:33%;" /><h2 id="一、初步认识Vue"><a href="#一、初步认识Vue" class="headerlink" title="一、初步认识Vue"></a>一、初步认识Vue</h2><h3 id="1、vue的编写规范"><a href="#1、vue的编写规范" class="headerlink" title="1、vue的编写规范"></a>1、vue的编写规范</h3><p>主要是用Flow，还有ts</p><h3 id="2、源码目录"><a href="#2、源码目录" class="headerlink" title="2、源码目录"></a>2、源码目录</h3><p>src</p><p>├ compiler        #编译相关</p><p>├ core                #核心代码</p><p>├ platforms       #不同平台的支持（web，weex）</p><p>├ server             #服务器渲染</p><p>├ sfc                    #对.vue文件的解析</p><p>├ shared             #公用部分，存放一些静态变量名，工具类</p><h3 id="3、源码构建"><a href="#3、源码构建" class="headerlink" title="3、源码构建"></a>3、源码构建</h3><p>基于Rollup，构建相关配置在package.json的scripts下，run不同的语句会编译出不同的vue版本。</p><h3 id="4、vue入口"><a href="#4、vue入口" class="headerlink" title="4、vue入口"></a>4、vue入口</h3><p>最上层的Vue类在*/src/core/instance/index.js。在这里会Mixin（混入）各种各样的模块，完成Vue的初始化。</p><h2 id="二、数据驱动"><a href="#二、数据驱动" class="headerlink" title="二、数据驱动"></a>二、数据驱动</h2><p>Vue.js一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作DOM，而是通过修改数据。它相比我们传统的前端开发，如使用jQuery等前端库直接修改DOM,大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为DOM变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触DOM，这样的代码非常利于维护。</p><h3 id="1、new-Vue发生了什么"><a href="#1、new-Vue发生了什么" class="headerlink" title="1、new Vue发生了什么"></a>1、new Vue发生了什么</h3><p>执行了*/src/core/instance/index.js 中的构造函数，并且进入到this._init(options)中（_init在*/src/core/instance/init.js中），会经历一系列的初始化，判断是否有重名，然后将数据、方法、props等挂载到vm上</p><h3 id="2、实例挂载实现了什么"><a href="#2、实例挂载实现了什么" class="headerlink" title="2、实例挂载实现了什么"></a>2、实例挂载实现了什么</h3><p>Vue中我们是通过$mount实例方法去挂载vm的，$mount 方法在多个文件中都有定义，如*/src/platform/web/ entry- runtime-with-compiler.js、*/src/platform/web/ runtime/ index.js、*/src/platform/weex/ runtime/index. js。因为$mount这个方法的实现是和平台、构建方式都相关的。</p><p>$mount在index.js &gt; initMixin(init.js中定义) &gt; Vue.prototype._init = function{……  if (vm.$options.el) {vm.$mount(vm.$options.el) }  }这里执行。（前面（即…处）执行了beforeCreate、created两个钩子，即生命周期的顺序。）</p><p>$mount是在entry-runtime-with-compiler.js（在带compiler的 版本中）中定义的。首先会把template（有多种方式获取）编译了，拿到render函数，然后再执行在Vue原型上的$mount。在Vue原型上的$mount上是有mountComponent的（在runtime-only版本中的index.js），mountComponent（在lifecycle.js中）调用beforeMount钩子，然后就是new Watcher() （在这new出来的是个渲染watcher），然后就mounted钩子了。</p><p>mountComponent函数在之后的更新视图中也会用到。</p><img src="image-20200502110200269.png" srcset="/img/loading.gif" alt="image-20200502110200269" style="zoom:50%;" /><img src="image-20200502110433648.png" srcset="/img/loading.gif" alt="image-20200502110433648" style="zoom:65%;" /><img src="image-20200429115053781.png" srcset="/img/loading.gif" alt="image-20200429115053781" style="zoom: 67%;" /><img src="image-20200429115623036.png" srcset="/img/loading.gif" alt="image-20200429115623036" style="zoom:67%;" /><p>总结：Vue实例里总会有一个render函数，如果定义的时候没有render函数，就会在执行过程中编译出一个render函数。在cli中，会有选择runtime-with-compiler/runtime-only，这个的意思就是，如果你选择runtime-with-compiler版本，就默认不认为你在定义的时候传入一个render函数，而是通过template、el、component等编译出render函数，然后再执行runtime（也即runtime-only）里的内容。选择runtime-only就意味着你在定义的时候就要传入一个render函数了，然后再设置挂载到哪个dom上。挂载过程：runtime-only.js内的$mount(){mountComponent}-&gt;mountComponent在lifecycle.js内有导出，在挂载的过程中，会new Watcher（没有执行），最后才挂载完成（即调用mounted钩子）。</p><p>new的这个Watcher就会实时观察到data的变化，虚拟DOM会重新渲染并应用更新（但其实这个过程中并不会再有mounted调用）（就如代码中，updateComponent执行了_update函数，_update函数执行了渲染函数）</p><img src="image-20200502121121603.png" srcset="/img/loading.gif" alt="image-20200502121121603" style="zoom:70%;" /><p>Watcher类在 */src/core/observer/watcher.js，watcher与响应式关系很强，之后更详细讲解。</p><p>ps.在mountComponent过程中，new的这个渲染watcher第二个参数传入的是updateComponent函数，new，然后进入到Watcher类内部，最后会执行this.get()，get函数是在Watcher类内部的，get函数内有this.getter = expOrFn（也即this.getter = updateComponent），该函数内部会以call的方式执行getter/updateComponent，并传入一个vm，但是这里的updateComponent是不接收任何参数的，所以猜测除了渲染watcher之外还有其他类型watcher，这里即使传入了vm给updateComponent也不做任何处理，仅updateComponent内部执行_update，_update内部执行_render，_render会返回一个vnode到_update（render细节见后文），然后这时才进入到_update函数体内，内部就会执行更新视图。这里传入的参数估计是为了其他类型watcher所设计。</p><img src="image-20200502163410108.png" srcset="/img/loading.gif" alt="image-20200502163410108" style="zoom:50%;" /><h3 id="3、render"><a href="#3、render" class="headerlink" title="3、render"></a>3、render</h3><p>路径：*/src/core/instance/render.js</p><p>Vue.prototype._render首先会取得vm.$options里的render函数（上面说过了render函数一般怎么生成的），然后以  vnode = render.call(vm._renderProxy, vm.$createElement)  的方式创建一个vnode，其中vm._renderProxy在init的时候已经创建好了，如果是在生产环境下就是vm本身。$createElement在render.js中initRender的（initRender在init.js里，初始化的时候就有执行了）开头有两种定义，第一种是用于编译出来的render函数，第二种是用户提供的render函数。实际上render拿到的返回值就是createElement的返回值。</p><p><img src="image-20200505112508410.png" srcset="/img/loading.gif" alt="image-20200505112508410" style="zoom: 67%;" /><img src="image-20200505112602051.png" srcset="/img/loading.gif" alt="image-20200505112602051" style="zoom:67%;" /></p><h3 id="4、Virtual-DOM"><a href="#4、Virtual-DOM" class="headerlink" title="4、Virtual DOM"></a>4、Virtual DOM</h3><p>Virtual DOM就是用一个原生的JS对象去描述一个DOM节点，所以它比创建一个DOM的代价要小很多。在Vue.js中，Virtual DOM是用VNode Class去描述，它是定义在src/core/vdom/vnode.js中的。</p><p>其中  data: VNodeData | void;  这个属性，期待的 VNodeData 类型在  */types/vnode.d.ts  中有定义。</p><p>其实Vue.js中的Virtual DOM是基于一个叫snabbdom的开源库实现的。</p><p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></p><p>总结：其实VNode是对真实DOM的一种抽象描述，它的核心定义就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展VNode的灵活性以及实现一些特殊 feature的。由于VNode只是用来映射到真实DOM的渲染，不需要包含操作DOM的方法，因此它是非常轻量和简单的。Virtual DOM除了它的数据结构的定义，映射到真实的DOM实际上要经历VNode的create、diff、patch 等过程。在Vue.js中，VNode的create是通过之前提到的createElement 方法创建的，实现方式见下文。</p><h3 id="5、createElement"><a href="#5、createElement" class="headerlink" title="5、createElement(*)"></a>5、createElement(*)</h3><p>路径：*/src/core/vdom/create-element.js</p><p>官方参数：</p><img src="image-20200508175815655.png" srcset="/img/loading.gif" alt="image-20200508175815655" style="zoom: 67%;" /><p>主要思路：</p><p>createElement 方法内部会先判断data的类型，因为传参的时候data是可以为空，然后就把后面的参数向后移位</p><img src="image-20200508112333309.png" srcset="/img/loading.gif" alt="image-20200508112333309" style="zoom:67%;" /><p>最后才是调用_createElement(context, tag, data, children, normalizationType)（返回一个VNode）：</p><img src="image-20200508112702352.png" srcset="/img/loading.gif" alt="image-20200508112702352" style="zoom: 67%;" /><p>1）判断传进来的data不能是响应式的，然后判断data.is(**)，如果有这个属性，就会进行相关的处理。（注意，在标签内使用v-bind:is，data.is也是undefined！因为这两个不是一样的东西！）。</p><p>2）判断“normalizationType === ALWAYS_NORMALIZE”，因为当我们手写render函数的时候，经常children那一项（即第二/三项）是传一个任意的数据，但是_createElement内部运行的时候，children要是一维的Array&lt;Node&gt;，所以就要对传入的这个任意类型数据进行格式化，其中有两种格式化方式：simpleNormalizeChildren和normalizeChildren。前者是编译生成的render才用的简单格式化方式，后者是手写render用的，可以完全保证格式化后children是个数组（ps.在simpleNormalizeChildren过程中，有种结果是会调用normalizeArrayChildren，在这个函数里有对文本VNode进行性能优化，如果前后两个VNode都是文本，就会合并这两个VNode为一个）。</p><img src="image-20200508181927801.png" srcset="/img/loading.gif" alt="image-20200508181927801" style="zoom:67%;" /><p>3）      如果tag是标签（字符串类型）：</p><p>​                        如果tag为HTML原生标签：</p><p>​                                            就创建一个原生标签VNode；</p><p>​                         如果(!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, ‘components’, tag))为</p><p>​                                            真：就创建一个组件VNode；</p><p>​                         啥都不是，就按照给定的数据创建一个特殊的VNode；</p><p>​              否则创建组件VNode；</p><img src="image-20200508224956330.png" srcset="/img/loading.gif" alt="image-20200508224956330" style="zoom:33%;" /><p>关于createComponent后面讲。</p><p>4）最后就是一系列的判断和在VNode上对:class,:style的深度绑定，最后的最后_createElement返回一个VNode </p><p>*<a href="https://cn.vuejs.org/v2/guide/render-function.html#createElement-参数" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/render-function.html#createElement-%E5%8F%82%E6%95%B0</a>，</p><p><a href="https://stackoverflow.com/questions/61675846/a-question-about-vue-js-source-code-in-function-createelement" target="_blank" rel="noopener">https://stackoverflow.com/questions/61675846/a-question-about-vue-js-source-code-in-function-createelement</a></p><p>**这是一个有关动态组件的属性，data对象是与模板中 attribute 对应的数据对象，参考<a href="https://cn.vuejs.org/v2/guide/render-function.html#深入数据对象" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1</a>，<a href="https://cn.vuejs.org/v2/guide/components.html#动态组件" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6</a></p><h3 id="6、update"><a href="#6、update" class="headerlink" title="6、update"></a>6、update</h3><p>路径：*/src/core/instance/lifecycle.js</p><p>Vue的_update是实例的一个私有方法，它被调用的时机有2个，首次渲染和数据更新。这里先只分析首次渲染，数据更新在之后关于响应式原理的时候写。_update方法的作用是把VNode渲染成真实的DOM。</p><img src="image-20200511092044826.png" srcset="/img/loading.gif" alt="image-20200511092044826" style="zoom:67%;" /><p>在该函数中首先会判断vue实例中是否已经存在Vnode（vm._vnode），因为update有两个触发时机，首次渲染和数据更新，如果不存在Vnode即为首次渲染，会执行__patch__函数，该函数在定义到Vue原型上之前会先判断</p><pre><code class="hljs ini"><span class="hljs-attr">Vue.prototype.__patch__</span> = inBrowser ? patch : noop<span class="hljs-comment">;</span></code></pre><p>即判断是否为浏览器环境（Vue也可以在weex中，这里只讨论浏览器），patch函数在  */src/platforms/web/runtime/patch.js  中定义，由createPatchFunction赋值得到，createPatchFunction在  */src/core/vdom/patch.js  中有导出。</p><img src="image-20200511153831668.png" srcset="/img/loading.gif" alt="image-20200511153831668" style="zoom:67%;" /><p>createPatchFunction的参数：nodeOps是一些对DOM的操作；modules是生成标签时的一些类、属性的钩子函数，在patch过程中会调用。（snabbdom的逻辑就是，当创建一个VNode时，调用一些相关的钩子函数以生成类、属性等，每个钩子函数对应一个module对应标签内的类/属性等）。</p><p>而createPatchFunction在*/src/core/vdom/patch.js中定义，在这个函数中会把所有的hooks和modules对应起来，以达到上面说的snabbdom的逻辑，并且还定义大量的辅助函数，只为最终返回的patch函数，这个函数就是上面提到的patch函数。</p><img src="image-20200511152314321.png" srcset="/img/loading.gif" alt="image-20200511152314321" style="zoom:80%;" /><p>为什么定义一个patch函数要绕一大圈，要经过createPatchFunction来创建：因为Vue.js可多平台运行的，为解决兼容多平台而可能造成的代码冗余，用了一种叫函数柯里化(***)的方法巧妙解决了，createPatchFunction顾名思义就是创建patch函数，在  */src/platforms/web/runtime/patch.js  中会生成对应平台（这里指web）所用到的modules，并传入createPatchFunction，这样在其他平台的使用的时候，也只需要生成其他平台所用到的modules传进createPatchFunction即可。</p><hr><img src="image-20200511160409935.png" srcset="/img/loading.gif" alt="image-20200511160409935" style="zoom:67%;" /><p>在patch中，先判断了oldVnode, vnode（分别对应于vm.$el,vnode，这里的vnode是由渲染函数创建出来的，上几节有讲）是否都有定义了，然后判断oldVnode是否为真实DOM，这里讨论首次渲染和浏览器环境的情况，所以必然为true，最后就用一个空的VNode来替代掉。</p><img src="image-20200511162205485.png" srcset="/img/loading.gif" alt="image-20200511162205485" style="zoom:67%;" /><p>这时oldVnode就真的是个VNode了，接下来要做的事情就是把vnode替换掉原来的oldVnode，即把vnode转换为真实的DOM：首先执行了createElm，该函数体内有</p><pre><code class="hljs reasonml">vnode.elm = vnode.ns  ? nodeOps.create<span class="hljs-constructor">ElementNS(<span class="hljs-params">vnode</span>.<span class="hljs-params">ns</span>, <span class="hljs-params">tag</span>)</span>  : nodeOps.create<span class="hljs-constructor">Element(<span class="hljs-params">tag</span>, <span class="hljs-params">vnode</span>)</span>set<span class="hljs-constructor">Scope(<span class="hljs-params">vnode</span>)</span>node_modules/vue/src/platforms/web/runtime/node-ops.js</code></pre><p>这里就是真正的调用原生API来创建DOM了，然后还会判断是否有子节点，如果有又会调用createChildren，createChildren又会递归调用createElm，确保所有子节点都能被创建，最后让子节点insert到父节点里面。（在insert函数内会对原生DOM进行操作）至此走完了createElm。</p><img src="image-20200511165922722.png" srcset="/img/loading.gif" alt="image-20200511165922722" style="zoom:67%;" /><p>回到patch中，因为是首次渲染，所以不需要递归的更新父占位节点元素，然后销毁旧的节点（在首次渲染中就是那个用于提供位点的&lt;div id=”app”&gt;&lt;/div&gt;），最后返回vnode.elm。</p><p>ps.hydrate：服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML字符串的形式交给浏览器, 最后经过”注水” hydrate 过程将一些事件绑定和Vue状态等注入到输出的静态的页面中, 由同步下发给浏览器的的Vue bundle接管状态, 继续处理接下来的交互逻辑。</p><p>***<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a></p><p>粗略的流程：</p><img src="image-20200511214625063.png" srcset="/img/loading.gif" alt="image-20200511214625063" style="zoom:70%;" /><h2 id="三、组件化"><a href="#三、组件化" class="headerlink" title="三、组件化"></a>三、组件化</h2><p>接下来的讲解均为使用vue-cli生成的模板，自带render。</p><h3 id="1、createComponent"><a href="#1、createComponent" class="headerlink" title="1、createComponent"></a>1、createComponent</h3><p>路径：*/src/core/vdom/create-component.js</p><img src="image-20200511212836159.png" srcset="/img/loading.gif" alt="image-20200511212836159" style="zoom:67%;" /><p>在执行到_createElement的时候，里面就走的是else里的代码了，执行createComponent，本质都是生成一个VNode。</p><p>待续…</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
