<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DOM事件</title>
    <link href="/2020/07/13/domevent/"/>
    <url>/2020/07/13/domevent/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>盒子模型</title>
    <link href="/2020/07/13/cssbox/"/>
    <url>/2020/07/13/cssbox/</url>
    
    <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>一个盒子包括：外边距、边框、内边距和实际内容。</p><img src="https://i.loli.net/2020/07/13/xDcrPEKMRydt8QI.png" srcset="/img/loading.gif" alt="img" style="zoom: 50%;" /><h2 id="二、标准盒子与-IE-盒子"><a href="#二、标准盒子与-IE-盒子" class="headerlink" title="二、标准盒子与 IE 盒子"></a>二、标准盒子与 IE 盒子</h2><p>标准盒子宽高 = content </p><p>IE盒子宽高 =  content + padding + border </p><img src="https://i.loli.net/2020/07/13/mCh8SvVsKfIAg7P.png" srcset="/img/loading.gif" alt="img" style="zoom: 67%;" /><img src="https://i.loli.net/2020/07/13/xbipVngTRCoDYwc.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;" /><pre><code class="hljs css">//设置标准盒子，默认<span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">content-box</span>;//设置IE盒子<span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;</code></pre><h2 id="三、获取宽-高"><a href="#三、获取宽-高" class="headerlink" title="三、获取宽/高"></a>三、获取宽/高</h2><pre><code class="hljs js"><span class="hljs-comment">// 只能获取内联样式设置的宽高</span>dom.style.width/height<span class="hljs-comment">// 获取渲染后即时运行的宽高，值是准确的。但只支持 IE</span>dom.currentStyle.width/height<span class="hljs-comment">// 获取渲染后即时运行的宽高，值是准确的。兼容性更好</span><span class="hljs-built_in">window</span>.getComputedStyle(dom).width/height;<span class="hljs-comment">// getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。</span>dom.getBoundingClientRect().width/height/left/top;</code></pre><h2 id="四、BFC-IFC"><a href="#四、BFC-IFC" class="headerlink" title="四、BFC/IFC"></a>四、BFC/IFC</h2><p>1、前置概念：</p><ol><li><p>Box: 布局的基本单位，元素类型和 display 属性，决定 Box 的类型。不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。</p><p>block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block formatting context；</p><p>inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context。</p></li><li><p>Formatting Context：这个概念规定了页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>BFC: Block Formatting Context，块级格式化上下文。</p><p>IFC: Inline Formatting Context，行级格式化上下文。</p></li></ol><p>2、详解：</p><ol><li>BFC：</li></ol><ul><li><p>布局规则：</p><ul><li>内部的Box会在垂直方向一个个放置，盒子之间垂直的间距是由 margin 决定。</li><li>在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul></li><li><p>创建BFC：</p><ul><li>float的值不是none。</li><li>position的值不是static或者relative。</li><li>overflow的值不是visible。</li><li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex。</li></ul></li><li><p>作用：</p><ul><li>利用BFC避免margin重叠。</li><li>自适应两栏布局。</li><li>清除浮动。</li></ul></li></ul><ol start="2"><li>IFC：</li></ol><ul><li>布局规则：<ul><li>内部的盒子会在水平方向，一个个地放置。</li><li>IFC的高度，由里面最高盒子的高度决定。</li><li>当一行不够放置的时候会自动切换到下一行。</li></ul></li></ul><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></p><p><a href="https://segmentfault.com/a/1190000013647777" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013647777</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p><p><a href="https://segmentfault.com/a/1190000013664630" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013664630</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>水平垂直居中的方法</title>
    <link href="/2020/07/13/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/13/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="水平垂直居中的方法"><a href="#水平垂直居中的方法" class="headerlink" title="水平垂直居中的方法"></a>水平垂直居中的方法</h1><h2 id="一、absolute-负margin"><a href="#一、absolute-负margin" class="headerlink" title="一、absolute + 负margin"></a>一、absolute + 负margin</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"out"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span>12345<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: 50%;    top: 50%;    margin-left: -50px;    margin-top: -50px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：好理解，兼容性很好。</p><p>缺点：需要知道子元素的宽高。</p><h2 id="二、absolute-auto-margin"><a href="#二、absolute-auto-margin" class="headerlink" title="二、absolute + auto margin"></a>二、absolute + auto margin</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: 0;    top: 0;    right: 0;    bottom: 0;    margin: auto;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：好理解，兼容性很好。</p><p>缺点：需要知道子元素的宽高。</p><h2 id="三、absolute-calc"><a href="#三、absolute-calc" class="headerlink" title="三、absolute + calc"></a>三、absolute + calc</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    width: 100px;    height: 100px;    background: yellow;    left: calc(50% - 50px);    top: calc(50% - 50px);  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：容易理解。</p><p>缺点：需要知道子元素的宽高，兼容性一般，需要支持calc。</p><h2 id="四、absolute-transform"><a href="#四、absolute-transform" class="headerlink" title="四、absolute + transform"></a>四、absolute + transform</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    position: relative;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    position: absolute;    background: yellow;    left: 50%;    top: 50%;    transform: translate(-50%, -50%);  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：不需要知道子元素的宽高。</p><p>缺点：兼容性一般，需要支持translate。</p><h2 id="五、table"><a href="#五、table" class="headerlink" title="五、table"></a>五、table</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: table-cell;    width: 300px;    height: 300px;    text-align: center;    vertical-align: middle;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    display: inline-block;    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：兼容性好。</p><p>缺点：要对table的使用很熟练。</p><h2 id="六、flex"><a href="#六、flex" class="headerlink" title="六、flex"></a>六、flex</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: flex;    justify-content: center;    align-items: center;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：简单。可通过父元素指定子元素的对齐方式，也可通过子元素自己指定自己的对齐方式来实现。</p><h2 id="七、grid"><a href="#七、grid" class="headerlink" title="七、grid"></a>七、grid</h2><pre><code class="hljs html">//方法一：父元素指定子元素的对齐方式<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: grid;    align-content: center;    justify-content: center;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>//方法二：子元素自己指定自己的对齐方式<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">  <span class="hljs-selector-class">.out</span>&#123;</span>    display: grid;    width: 300px;    height: 300px;    background: red;  &#125;<span class="css">  <span class="hljs-selector-class">.inner</span>&#123;</span>    background: yellow;    width: 100px;    height: 100px;    align-self: center;    justify-self: center;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>优点：简单。可通过父元素指定子元素的对齐方式，也可通过子元素自己指定自己的对齐方式来实现。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p><p><a href="https://blog.csdn.net/messagebox_/article/details/82380913" target="_blank" rel="noopener">https://blog.csdn.net/messagebox_/article/details/82380913</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/display</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面布局</title>
    <link href="/2020/07/13/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <url>/2020/07/13/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><p>多种方式实现三栏布局</p><h2 id="一、float布局"><a href="#一、float布局" class="headerlink" title="一、float布局"></a>一、float布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout float"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.wrapper</span>&gt;<span class="hljs-selector-tag">div</span> &#123;</span>        min-height: 100px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.left</span> &#123;</span>        float: left;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.center</span> &#123;</span>        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.float</span> <span class="hljs-selector-class">.right</span> &#123;</span>        float: right;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>float布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是float布局的中间部分        2.我是float布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单，兼容性比较好。注意需要清除浮动。<br>缺点：浮动元素是脱离文档流，清除浮动处理不好会出现高度塌陷等问题。</p><h2 id="二、绝对布局"><a href="#二、绝对布局" class="headerlink" title="二、绝对布局"></a>二、绝对布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout absolute"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        width: 100%;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.wrapper</span>&gt;<span class="hljs-selector-tag">div</span> &#123;</span>        min-height: 100px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.left</span> &#123;</span>        position: absolute;        left: 0;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.center</span> &#123;</span>        position: absolute;        left: 300px;        right: 300px;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.absolute</span> <span class="hljs-selector-class">.right</span> &#123;</span>        position: absolute;        right: 0;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>absolute布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是absolute布局的中间部分        2.我是absolute布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单，兼容性比较好。<br>缺点：绝对定位是脱离文档流的，下面的所有子元素也会脱离文档流，导致这种方法的有效性和可使用性是比较差的。</p><h2 id="三、flex布局"><a href="#三、flex布局" class="headerlink" title="三、flex布局"></a>三、flex布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout flex"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        width: 100%;        min-height: 100px;        display: flex;        margin-top: 140px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.left</span> &#123;</span>        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.center</span> &#123;</span>        flex: 1;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.flex</span> <span class="hljs-selector-class">.right</span> &#123;</span>        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>flex布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是flex布局的中间部分        2.我是flex布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：不支持 IE8 及以下。</p><h2 id="四、table布局"><a href="#四、table布局" class="headerlink" title="四、table布局"></a>四、table布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout table"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        display: table;        width: 100%;        min-height: 100px;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.left</span> &#123;</span>        display: table-cell;        width: 300px;        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.center</span> &#123;</span>        display: table-cell;        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.table</span> <span class="hljs-selector-class">.right</span> &#123;</span>        display: table-cell;        width: 300px;        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>table布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是table布局的中间部分        2.我是table布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。</p><h2 id="五、grid布局"><a href="#五、grid布局" class="headerlink" title="五、grid布局"></a>五、grid布局</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layout grid"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"screen"</span>&gt;</span><span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.wrapper</span> &#123;</span>        display: grid;        grid-template-columns: 300px auto 300px;        grid-template-rows: 100px;        width: 100%;        margin-top: 20px;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.left</span> &#123;</span>        background: red;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.center</span> &#123;</span>        background: yellow;      &#125;<span class="css">      <span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.grid</span> <span class="hljs-selector-class">.right</span> &#123;</span>        background: blue;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>grid布局<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        1.我是grid布局的中间部分        2.我是grid布局的中间部分      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>优点：设置简单。<br>缺点：不支持 IE8 及以下。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>预处理器</title>
    <link href="/2020/07/06/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2020/07/06/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><h2 id="一、什么是CSS预处理器"><a href="#一、什么是CSS预处理器" class="headerlink" title="一、什么是CSS预处理器"></a>一、什么是CSS预处理器</h2><p>CSS预处理器会是能让你通过预处理器独有的语法来生成CSS。还增加一些原生CSS不具备的特性，让CSS的结构更加具有可读性且易于维护。帮助更好地组织CSS代码，提高代码的复用率，提升可维护性。但是有学习使用成本。</p><p>常见的有Sass、LESS、PostCSS 和 Stylus。</p><h2 id="二、Sass"><a href="#二、Sass" class="headerlink" title="二、Sass"></a>二、Sass</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><pre><code class="hljs scss"><span class="hljs-variable">$side</span> : left;<span class="hljs-variable">$black</span> : <span class="hljs-number">#000</span>.rounded &#123;color: <span class="hljs-variable">$black</span>;<span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$side</span>&#125;-radius: <span class="hljs-number">5px</span>;&#125;</code></pre><h3 id="2-计算"><a href="#2-计算" class="headerlink" title="2. 计算"></a>2. 计算</h3><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">margin</span>: (<span class="hljs-number">14px</span>/<span class="hljs-number">2</span>);    <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span> + <span class="hljs-number">100px</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-variable">$var</span> * <span class="hljs-number">10%</span>;&#125;</code></pre><h3 id="3-嵌套"><a href="#3-嵌套" class="headerlink" title="3. 嵌套"></a>3. 嵌套</h3><p>&amp; ：父选择器</p><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;  <span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">color</span>: red;    <span class="hljs-selector-tag">header</span> &amp; &#123;      <span class="hljs-attribute">color</span>:green;      <span class="hljs-attribute">border</span>: &#123;      top: <span class="hljs-number">1px</span> solid red;      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">1px</span> solid green;      &#125;    &#125;  &#125;  &#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: green;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid red;  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid green;&#125;</code></pre><pre><code class="hljs scss">伪类嵌套：&amp;和相连的类名之间不能有任何的空格,否则变为上述的后代选择器<span class="hljs-selector-class">.clearfix</span>&#123;    &amp;<span class="hljs-selector-pseudo">:before</span>,    &amp;<span class="hljs-selector-pseudo">:after</span> &#123;        <span class="hljs-attribute">content</span>:<span class="hljs-string">""</span>;        <span class="hljs-attribute">display</span>: table;    &#125;    &amp;<span class="hljs-selector-pseudo">:after</span> &#123;        <span class="hljs-attribute">clear</span>:both;        <span class="hljs-attribute">overflow</span>: hidden;    &#125;&#125;<span class="hljs-comment">// 编译后</span>clearfix<span class="hljs-selector-pseudo">:before</span>, <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;  <span class="hljs-attribute">display</span>: table;&#125;<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">overflow</span>: hidden;&#125;</code></pre><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><p>test：标准CSS注释，会有输出；test2：Sass注释，无输出；test3：压缩模式下也有输出</p><pre><code class="hljs sass">&#x2F;* test *&#x2F;&#x2F;&#x2F; test2&#x2F;*   test3*&#x2F;&#x2F;&#x2F; 编译后&#x2F;* test *&#x2F;&#x2F;*   test3*&#x2F;</code></pre><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h3><pre><code class="hljs scss"><span class="hljs-selector-class">.btn</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">10px</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.btn-primary</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f36</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-keyword">@extend</span> .btn;&#125;<span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">background-color</span>: orange;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-keyword">@extend</span> .btn;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-class">.btn</span>, <span class="hljs-selector-class">.btn-primary</span>, <span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">10px</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;&#125;<span class="hljs-selector-class">.btn-primary</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f36</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.btn-second</span> &#123;  <span class="hljs-attribute">background</span>-clor: orange;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;</code></pre><h3 id="6-Mixin"><a href="#6-Mixin" class="headerlink" title="6. Mixin"></a>6. Mixin</h3><p>@include调用@mixin</p><pre><code class="hljs scss"><span class="hljs-comment">// 无默认值</span><span class="hljs-keyword">@mixin</span> left &#123;<span class="hljs-attribute">float</span>: left;<span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123; <span class="hljs-keyword">@include</span> left; &#125;<span class="hljs-comment">// 有默认值，不传参就编译出默认值</span><span class="hljs-keyword">@mixin</span> left(<span class="hljs-variable">$value</span>: <span class="hljs-number">10px</span>) &#123;    <span class="hljs-attribute">float</span>: left;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-variable">$value</span>;&#125;<span class="hljs-selector-tag">div</span> &#123; <span class="hljs-keyword">@include</span> left(<span class="hljs-number">20px</span>); &#125;<span class="hljs-comment">// 组合用法</span><span class="hljs-keyword">@mixin</span> rounded(<span class="hljs-variable">$vert</span>, <span class="hljs-variable">$horz</span>, <span class="hljs-variable">$radius</span>: <span class="hljs-number">10px</span>) &#123;    <span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;-#&#123;<span class="hljs-variable">$horz</span>&#125;-radius: <span class="hljs-variable">$radius</span>;    -moz-<span class="hljs-attribute">border-radius</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;#&#123;<span class="hljs-variable">$horz</span>&#125;: <span class="hljs-variable">$radius</span>;    -webkit-<span class="hljs-attribute">border</span>-#&#123;<span class="hljs-variable">$vert</span>&#125;-#&#123;<span class="hljs-variable">$horz</span>&#125;-radius: <span class="hljs-variable">$radius</span>;&#125;<span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-keyword">@include</span> rounded(top, left); &#125;<span class="hljs-selector-id">#footer</span> &#123; <span class="hljs-keyword">@include</span> rounded(top, left, <span class="hljs-number">5px</span>); &#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">float</span>: left;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">float</span>: left;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">10px</span>;  -moz-<span class="hljs-attribute">border-radius</span>-topleft: <span class="hljs-number">10px</span>;  -webkit-<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-id">#footer</span> &#123;  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">5px</span>;  -moz-<span class="hljs-attribute">border-radius</span>-topleft: <span class="hljs-number">5px</span>;  -webkit-<span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">5px</span>;&#125;</code></pre><h3 id="7-import"><a href="#7-import" class="headerlink" title="7. @import"></a>7. @import</h3><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">"path/filename.scss"</span>;<span class="hljs-keyword">@import</span> <span class="hljs-string">"foo.css"</span>;  <span class="hljs-comment">//</span></code></pre><h3 id="8-if-else"><a href="#8-if-else" class="headerlink" title="8. @if/@else"></a>8. @if/@else</h3><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">50%</span>;<span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-keyword">@if</span> <span class="hljs-variable">$a</span> &gt; <span class="hljs-number">30%</span> &#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125; <span class="hljs-keyword">@else</span> &#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;    &#125;&#125;</code></pre><h3 id="9-循环"><a href="#9-循环" class="headerlink" title="9. 循环"></a>9. 循环</h3><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from &lt;start&gt; through &lt;end&gt;  // 包括end<span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from &lt;start&gt; to &lt;end&gt;  // 不包括end<span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> to <span class="hljs-number">3</span> &#123;    <span class="hljs-selector-class">.border-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123;        <span class="hljs-attribute">border</span>: #&#123;<span class="hljs-variable">$i</span>&#125;px solid blue;    &#125;&#125;<span class="hljs-variable">$i</span>: <span class="hljs-number">4</span>;<span class="hljs-keyword">@while</span> <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<span class="hljs-variable">$i</span>: <span class="hljs-variable">$i</span> - <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">@each</span> <span class="hljs-variable">$member</span> in a, b &#123;    .#&#123;<span class="hljs-variable">$member</span>&#125; &#123;    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/#&#123;$member&#125;.jpg"</span>);    &#125;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-class">.border-1</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;&#125;<span class="hljs-selector-class">.border-2</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;&#125;<span class="hljs-selector-class">.item-4</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">8em</span>;&#125;<span class="hljs-selector-class">.item-2</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>;&#125;<span class="hljs-selector-class">.a</span> &#123;  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/a.jpg"</span>);&#125;<span class="hljs-selector-class">.b</span> &#123;  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">"/image/b.jpg"</span>);&#125;</code></pre><h3 id="10-自定义函数"><a href="#10-自定义函数" class="headerlink" title="10. 自定义函数"></a>10. 自定义函数</h3><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> double(<span class="hljs-variable">$n</span>) &#123;    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$n</span> * <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-selector-id">#sidebar</span> &#123;    <span class="hljs-attribute">width</span>: double(<span class="hljs-number">5px</span>);&#125;</code></pre><h3 id="11-media"><a href="#11-media" class="headerlink" title="11. @media"></a>11. @media</h3><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> screen &#123;  <span class="hljs-selector-class">.sidebar</span> &#123;    <span class="hljs-keyword">@media</span> (orientation: landscape) &#123;      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;    &#125;  &#125;&#125;<span class="hljs-comment">// 编译后</span><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;  <span class="hljs-selector-class">.sidebar</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  &#125;&#125;</code></pre><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a href="https://github.com/lyanmm/front-end-note/blob/master/其他/sass.docx" target="_blank" rel="noopener">Sass笔记</a></p><p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p><p><a href="https://sass-lang.com/" target="_blank" rel="noopener">https://sass-lang.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>应用层协议</title>
    <link href="/2020/07/05/HTTPandDNS/"/>
    <url>/2020/07/05/HTTPandDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="一、HTTP-HTTPS"><a href="#一、HTTP-HTTPS" class="headerlink" title="一、HTTP/HTTPS"></a>一、HTTP/HTTPS</h2><h3 id="1-概况"><a href="#1-概况" class="headerlink" title="1. 概况"></a>1. 概况</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。使用 TCP 作为传输层协议。HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p><h3 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h3><p>1）请求报文</p><p><img src="https://i.loli.net/2020/07/05/nU2BvTIfHsCER3V.png" srcset="/img/loading.gif" alt="request"></p><p>HTTP请求报文包括：请求行、请求头、空行 和 实体主体 。</p><p>请求行包含：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段：</p><ul><li>GET 方法只被用于向服务器获取数据。</li><li>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。</li><li>HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含响应体。</li><li>PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。</li></ul><p>请求方法更多表达的是语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看如何选择。更多方法可参看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">文档</a>。</p><p>2）响应报文</p><pre><code class="hljs angelscript">HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OKContent-Type: text/plainContent-Length: <span class="hljs-number">137582</span>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMTLast-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMTServer: Apache <span class="hljs-number">0.84</span>&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTTP 响应报文包括：状态行、响应头、空行 和 实体主体</p><p>状态行包含：协议版本字段、状态码 和 状态信息。</p><h3 id="3-请求-响应头"><a href="#3-请求-响应头" class="headerlink" title="3. 请求/响应头"></a>3. 请求/响应头</h3><p>有两种类型：请求首部、通用首部和实体首部；响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p><h3 id="4-HTTP版本"><a href="#4-HTTP版本" class="headerlink" title="4. HTTP版本"></a>4. HTTP版本</h3><p>HTTP/1.1：</p><ul><li>使用持久连接，多个请求可复用同一个 TCP 连接。</li><li>服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，容易造成排队的情况，称为“队头堵塞”。队头堵塞会导致持久连接在达到最大数量时，剩余的资源要等其他资源请求完后才能发起请求。为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的原因。</li></ul><p>HTTP/2 ：</p><ul><li>彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。</li><li>每个请求或回应的所有数据包，称为一个数据流。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流，因为同一个连接里面连续的数据包，可能属于不同的请求。</li><li>引入了头信息压缩机制，头信息压缩后发送，并且客户端和服务器维护一张<u>头信息表</u>，所有字段都会存入这个表，生成一个<u>索引号</u>，以后就只发送索引号，提高速度。</li><li>允许服务器未经请求，主动向客户端推送静态资源，注意区别 WebSocket 等等。</li><li>因为用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，<u>遵守同一个</u>流量状态控制和拥塞控制。<u>只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去</u>。出现该问题是由于其使用 TCP 协议，与协议本身的实现其实没多大关系。</li></ul><p>HTTP/3 ：</p><ul><li>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能。</li></ul><h3 id="5-状态码"><a href="#5-状态码" class="headerlink" title="5. 状态码"></a>5. 状态码</h3><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><h3 id="6-TLS-SSL-协议"><a href="#6-TLS-SSL-协议" class="headerlink" title="6. TLS/SSL 协议"></a>6. TLS/SSL 协议</h3><p>用于 HTTPS 的加密。</p><p>TLS 握手过程：</p><ol><li>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 值，用来供服务器检验。</li><li>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ol><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><p><a href="https://www.cnblogs.com/myseries/p/11239662.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11239662.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p><h2 id="二、DNS"><a href="#二、DNS" class="headerlink" title="二、DNS"></a>二、DNS</h2><h3 id="1-概况-1"><a href="#1-概况-1" class="headerlink" title="1. 概况"></a>1. 概况</h3><p>DNS 协议提供主机名到 IP 地址的转换服务，即Domain Name System，域名系统。DNS 协议运行在 <u>UDP 协议</u>之上，使用 <u>53 号</u>端口。</p><h3 id="2-层级结构"><a href="#2-层级结构" class="headerlink" title="2. 层级结构"></a>2. 层级结构</h3><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做 次级域名（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为 三级域名，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><pre><code class="hljs bash">主机名.次级域名.顶级域名.根域名<span class="hljs-comment"># 即</span>host.sld.tld.root</code></pre><h3 id="3-查询过程"><a href="#3-查询过程" class="headerlink" title="3. 查询过程"></a>3. 查询过程</h3><ol><li>将请求发送到<u>本地 DNS 服务器</u>中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求。</li><li>从”根域名服务器”查到”顶级域名服务器”的 NS(Name Server) 记录和 A 记录（ IP 地址）。</li><li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从”次级域名服务器”查出”主机名”的 IP 地址。</li></ol><p>一般我们<u>向本地 DNS 服务器发送请求的方式就是递归查询</u>，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我们最终的请求结果。而<u>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询</u>，因为每一次域名服务器只返回单次查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="4-DNS-记录和报文"><a href="#4-DNS-记录和报文" class="headerlink" title="4. DNS 记录和报文"></a>4. DNS 记录和报文</h3><p>DNS 服务器中以<u>资源记录</u>的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p>（<u>Name</u>，<u>Value</u>，<u>Type</u>，<u>TTL</u>）</p><p>其中 TTL （Time To Live）是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li>如果 Type = A，则 Name 是<u>主机名</u>，Value 是<u>主机名对应的 IP 地址</u>。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。</li><li>如果 Type = NS，则 Name 是个<u>域名</u>，Value 是<u>负责该域名的 DNS 服务器的主机名</u>。这个记录主要用于 DNS 链式查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type = CNAME，则 Name 为<u>别名</u>，Value 为<u>该主机的规范主机名</u>。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供一个便于记忆的简单的别名。</li><li>如果 Type = MX，则 Name 为<u>邮件服务器的别名</u>，Value 为<u>邮件服务器的规范主机名</u>。它的作用和 CNAME 是一样的，都是为了解决规范主机名不利于记忆的缺点。</li></ol><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/05/root-domain.html</a></p><h2 id="三、其他协议"><a href="#三、其他协议" class="headerlink" title="三、其他协议"></a>三、其他协议</h2><ol><li>文件传输协议(File Transfer Protocol，FTP)：用于实现交互式文件传输功能。</li><li>简单邮件传送协议(Simple Mail Transfer Protocol, SMTP)：用于实现电子邮箱传送功能。</li><li>简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。</li><li>远程登录协议(Telnet)：用于实现远程登录功能。</li><li>邮局协议版本3(Post Office Protocol - Version 3，POP3)：只下载邮件，服务器端并不删除。</li><li>交互邮件访问协议(Internet Mail Access Protocol，IMAP)：从邮件服务器上获取邮件的信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步请求</title>
    <link href="/2020/07/05/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/07/05/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><h2 id="一、异步"><a href="#一、异步" class="headerlink" title="一、异步"></a>一、异步</h2><p>JavaScript中主要有四种异步的实现方式。</p><h3 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. 回调函数</h3><p>使用回调函数的缺点是，多个回调函数嵌套的时候会造成回调函数地狱，代码耦合度高，不利于代码维护。</p><h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p>1）概念：</p><ul><li>Promise对象是一个构造函数，用来生成Promise实例。</li><li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</li><li>Promise对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li><li>Promise对象的状态改变，只有两种可能：从pending变为 fulfilled 和从pending变为 rejected 。要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。</li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 基本</span><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ... some code</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;    resolve(value);  &#125; <span class="hljs-keyword">else</span> &#123;    reject(error);  &#125;&#125;);<span class="hljs-comment">// 链式</span>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-comment">// success</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;  <span class="hljs-comment">// failure</span>&#125;);promise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result));promise.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error));</code></pre><h3 id="3-Generator-函数"><a href="#3-Generator-函数" class="headerlink" title="3. Generator 函数"></a>3. Generator 函数</h3><p>1）概念：</p><ul><li><p>Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。</p></li><li><p>执行 Generator 函数会返回一个遍历器对象，可以是一个遍历器对象生成函数。</p></li><li><p>Generator.prototype.next()</p><p>返回一个由 yield表达式生成的值。</p><p>Generator.prototype.return()</p><p>返回给定的值并结束生成器。</p><p>Generator.prototype.throw()</p><p>向生成器抛出一个错误。</p></li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">helloWorldGenerator</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;  <span class="hljs-keyword">yield</span> <span class="hljs-string">'world'</span>;  <span class="hljs-keyword">return</span> <span class="hljs-string">'ending'</span>;&#125;<span class="hljs-keyword">var</span> hw = helloWorldGenerator();hw.next()  <span class="hljs-comment">// &#123; value: 'hello', done: false &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: 'world', done: false &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: 'ending', done: true &#125;</span>hw.next()  <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> helloWorldGenerator()) &#123;  <span class="hljs-built_in">console</span>.log(v);&#125;<span class="hljs-comment">// hello,world,ending</span></code></pre><h3 id="4-async-函数"><a href="#4-async-函数" class="headerlink" title="4. async 函数"></a>4. async 函数</h3><p>1）概念：</p><ul><li>本质上是是 Generator 函数的语法糖。</li><li>将 Generator 函数的星号（*）替换成async，将yield替换成await。</li><li>改进：拥有更好的语义，返回Promise对象，函数体内用 await 表示后面有需要等待的异步操作，await 还能接原始类型。</li></ul><p>2）用法：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">interval</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    setTimeout(resolve, interval);  &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one2FiveInAsync</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-built_in">console</span>.log(i);    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);  &#125;&#125;one2FiveInAsync();<span class="hljs-comment">// 例二</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">url</span>) </span>&#123;  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();  <span class="hljs-keyword">return</span> html.match(<span class="hljs-regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-number">1</span>];&#125;getTitle(<span class="hljs-string">'https://tc39.github.io/ecma262/'</span>).then(<span class="hljs-built_in">console</span>.log)<span class="hljs-comment">// "ECMAScript 2017 Language Specification"</span></code></pre><h2 id="二、请求"><a href="#二、请求" class="headerlink" title="二、请求"></a>二、请求</h2><p>AJAX 即”Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。</p><h3 id="1-XMLHttpRequest"><a href="#1-XMLHttpRequest" class="headerlink" title="1. XMLHttpRequest"></a>1. XMLHttpRequest</h3><p>xhr.readyState</p><ul><li>0 - (未初始化)，还没有调用send()</li><li>1 - (载入)，已调用send()，正在发送请求</li><li>2 - (载入完成)，send()方法执行完成，已接收到全部的响应内容</li><li>3 - (交互)，正在解析响应内容</li><li>4 - (完成)，响应内容解析完成，可以在客户端调用</li></ul><p>xhr.status</p><ul><li>1xx - 指示信息，表示资源已经请求，继续处理</li><li>2xx - 表示成功处理请求，如200</li><li>3xx - 需要重定向，浏览器直接跳转<ul><li>301 - 永久重定向，每次访问A地址的时候，浏览器会自动跳到B地址</li><li>302 - 临时重新向，仅一次访问A地址时调到B，下次访问还是跳到A</li><li>304 - 资源未改变，若请求返回的资源与之前的相比没发生改变，服务器会返回304，浏览器会使用自己先前缓存的资源</li></ul></li><li>4xx - 客户端请求错误<ul><li>400 - 客户端请求有语法错误，不能被服务器端所理解</li><li>401 - 请求未经过授权，这个状态码必须和WWW-Authenticate报头域一起使用</li><li>403 - 服务器收到请求，但是拒绝提供该服务</li><li>404 - 请求的地址错误</li></ul></li><li>5xx - 服务端错误<ul><li>500 - 服务器发生不可预期的错误</li><li>503 - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul></li></ul><p>示例：</p><pre><code class="hljs js"><span class="hljs-comment">// 基本过程</span><span class="hljs-keyword">new</span> -&gt; open() -&gt; send(),设置监听函数，等待响应。<span class="hljs-comment">// get请求</span><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'./data/test.json'</span>, <span class="hljs-literal">true</span>)xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;      <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;xhr.send(<span class="hljs-literal">null</span>)<span class="hljs-comment">// post请求</span><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'/login'</span>, <span class="hljs-literal">true</span>)xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;      <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> postData = &#123;  name: <span class="hljs-string">'zhangsan'</span>,  password: <span class="hljs-string">'123'</span>&#125;xhr.send(<span class="hljs-built_in">JSON</span>.stringify(postData))</code></pre><h3 id="2-Fetch-API"><a href="#2-Fetch-API" class="headerlink" title="2. Fetch API"></a>2. Fetch API</h3><p>一个全局 API ，可用于发送请求，返回 Promise 对象。</p><p>注意：当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</p><pre><code class="hljs js">fetch(<span class="hljs-string">'http://example.com/movies.json'</span>,[&#123;options&#125;])  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-keyword">return</span> response.json();  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">myJson</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(myJson);  &#125;);</code></pre><h3 id="3-Axios"><a href="#3-Axios" class="headerlink" title="3. Axios"></a>3. Axios</h3><p>一个基于 promise 的 HTTP 库，可以用在浏览器和 Node.js 中。</p><p>$ npm install axios</p><p>主要方法：</p><p>axios.create([config])</p><p>axios.get(url[, config])</p><p>axios.post(url[, data[, config]])</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">let</span> instance = axios.create(&#123;  baseURL: <span class="hljs-string">'https://some-domain.com/api/'</span>    ...&#125;);<span class="hljs-comment">// 可以直接使用引入的对象发起请求</span>axios.get(<span class="hljs-string">'/user?ID=12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(error);  &#125;);<span class="hljs-comment">// 可以使用实例发起请求</span>instance.get(<span class="hljs-string">'/user?ID=12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)<span class="hljs-comment">// 其他请求方式同理</span>axios.post(<span class="hljs-string">'/user'</span>, &#123;    firstName: <span class="hljs-string">'Fred'</span>,    lastName: <span class="hljs-string">'Flintstone'</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response);  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(error);  &#125;);</code></pre><p>实际开发中会把函数设置为async，并在请求前加上await。</p><p>响应报文：</p><pre><code class="hljs js">&#123;  data: &#123;&#125;,  <span class="hljs-comment">// `data` 由服务器提供的响应</span>  status: <span class="hljs-number">200</span>,  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span>  statusText: <span class="hljs-string">'OK'</span>,  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>  headers: &#123;&#125;,  <span class="hljs-comment">// `headers` 服务器响应的头</span>  config: &#123;&#125;  <span class="hljs-comment">// `config` 是为请求提供的配置信息</span>&#125;axios.get(<span class="hljs-string">'/user/12345'</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(response.data);    <span class="hljs-built_in">console</span>.log(response.status);    <span class="hljs-built_in">console</span>.log(response.statusText);    <span class="hljs-built_in">console</span>.log(response.headers);    <span class="hljs-built_in">console</span>.log(response.config);  &#125;);</code></pre><h2 id="三、URI-URL"><a href="#三、URI-URL" class="headerlink" title="三、URI/URL"></a>三、URI/URL</h2><p>URI: Uniform Resource Identifier      指的是统一资源标识符<br>URL: Uniform Resource Location        指的是统一资源定位符<br>URN: Universal Resource Name          指的是统一资源名称</p><p>URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</p><p>URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</p><pre><code class="hljs js"><span class="hljs-comment">// 假设当前url为： https://coding.imooc.com/lesson/115.html&amp;a=100#mid=30378</span><span class="hljs-built_in">console</span>.log(location.protocol)  <span class="hljs-comment">// 'https:'</span><span class="hljs-built_in">console</span>.log(location.host)      <span class="hljs-comment">// 'coding.imooc.com'</span><span class="hljs-built_in">console</span>.log(location.pathname)  <span class="hljs-comment">// '/lesson/115.html'</span><span class="hljs-built_in">console</span>.log(location.search)    <span class="hljs-comment">// '?a=100'</span><span class="hljs-built_in">console</span>.log(location.hash)      <span class="hljs-comment">// '#mid=30378'</span></code></pre><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API</a></p><p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></p><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对DOM和Virtual DOM的理解</title>
    <link href="/2020/07/05/DOMandVDOM/"/>
    <url>/2020/07/05/DOMandVDOM/</url>
    
    <content type="html"><![CDATA[<h1 id="对DOM和Virtual-DOM的理解"><a href="#对DOM和Virtual-DOM的理解" class="headerlink" title="对DOM和Virtual DOM的理解"></a>对DOM和Virtual DOM的理解</h1><h2 id="一、DOM"><a href="#一、DOM" class="headerlink" title="一、DOM"></a>一、DOM</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>MDN：文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。</p><p>理解：DOM就是对文档（HTML/XML）操作的接口。在DOM的概念里，将文档各种节点抽象成了一颗节点树（根节点是document），可以用各种接口对这颗树进行修改，从而改变文档所展示出来的结果。并不是说DOM是一颗节点树（DOM 是HTML和XML文档的编程接口），而是因为这些接口的存在，才把文档构建成了一颗树。</p><h3 id="2-DOM和JS的关系"><a href="#2-DOM和JS的关系" class="headerlink" title="2. DOM和JS的关系"></a>2. DOM和JS的关系</h3><ul><li><p>区别：DOM 跟编程语言（ JS 等等）是互相独立的，DOM译为文档对象模型，只是一种模型、结构，很多语言都能使用。</p></li><li><p>联系：DOM + JS 能组成一个web页面。</p></li></ul><h3 id="3-节点和节点树"><a href="#3-节点和节点树" class="headerlink" title="3. 节点和节点树"></a>3. 节点和节点树</h3><ol><li><p>DOM 的最小组成单位叫做节点（Node）。节点树/DOM树 就是由节点组成的。浏览器提供一个原生节点对象 Node ，所有的节点都继承自这个对象，拥有一些共同的属性和方法，这是 DOM 操作的基础。</p></li><li><p>注意区分 文档节点 和 文档元素 ：在HTML中，文档节点一般就是指根节点document，而文档元素就是指&lt;html&gt;元素，每个文档都只能有一个文档元素。</p></li><li><p>在HTML中，Node有7种类型：</p></li></ol><ul><li><code>Document</code>：整个文档树的顶层节点</li><li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li><li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li><li><code>Attr</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li><li><code>Text</code>：标签之间或标签包含的文本</li><li><code>Comment</code>：注释</li><li><code>DocumentFragment</code>：文档的片段</li></ul><ol start="4"><li>Node原型上定义了许多的方法和属性，document节点也是继承自Node的，所以才能这样使用 document.querySelector 方法等等，还有获取 document.getElementsByTagName(‘html’)[0].nodeType 属性等等。</li><li>说白了就是用接口提供的Node对象上的方法和属性来修改和查看DOM树，来对页面修改。</li></ol><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h3><p><a href="http://luopq.com/2015/11/30/javascript-dom/" target="_blank" rel="noopener">http://luopq.com/2015/11/30/javascript-dom/</a></p><p><a href="https://wangdoc.com/javascript/dom/general.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/dom/general.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction</a></p><p>《JavaScript高级程序设计》（点击查看大图）</p><img src="https://i.loli.net/2020/07/05/a8vh347gnFr1BCf.png" srcset="/img/loading.gif" alt="image-20200705103854234" style="zoom:25%;" /><img src="https://i.loli.net/2020/07/05/iPYFSqKMwGOJQng.png" srcset="/img/loading.gif" alt="image-20200705103747825" style="zoom: 25%;" /><h2 id="二、Virtual-DOM"><a href="#二、Virtual-DOM" class="headerlink" title="二、Virtual DOM"></a>二、Virtual DOM</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>用 JS 模拟 DOM 结构，将 DOM 变化的对比放在 JS 层来做，实际上VDOM就是 JS 对象。</p><p>使用Virtual DOM ：render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></p><h3 id="2-为什么要用Virtual-DOM"><a href="#2-为什么要用Virtual-DOM" class="headerlink" title="2. 为什么要用Virtual DOM"></a>2. 为什么要用Virtual DOM</h3><ul><li>性能上直接操作真实 DOM 代价高</li><li>在框架中使用 VDOM 可以为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。</li></ul><h3 id="3-diff算法"><a href="#3-diff算法" class="headerlink" title="3. diff算法"></a>3. diff算法</h3><ul><li><p>最早用于解决LCS（最长公共子串）问题，找出两个序列之间的公共子序列。</p></li><li><p>在VDOM中使用传统diff算法，会跨级对比两个树之间的不同，时间复杂度为O(n<sup>3</sup>)。</p></li><li><p>在Vue中，diff 优化后只比较树的同层级，为O(n)。</p><p>实现方式：（这里只演示diff算法，具体的 VDOM 是如何更新的不演示）（在 diff 比较过程中，循环从两边向中间收拢）</p><p>1）首先列出新老节点比较的可能情况：</p><ul><li>当新老 VNode 节点的 start 满足 sameVnode 时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</li><li>当新老 VNode 节点的 end 满足 sameVnode 时，同样直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</li><li>当老 VNode 节点的 <u>start</u> 和新 VNode 节点的 <u>end</u> 满足 sameVnode 时，说明这次数据更新后 oldStartVnode 到了 oldEndVnode <u>后面</u>了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的<u>后面</u>，同时老 VNode 节点开始索引<u>加 1</u>，新 VNode 节点的结束索引<u>减 1</u>。</li><li>当老 VNode 节点的 <u>end</u> 和新 VNode 节点的 <u>start</u> 满足 sameVnode 时，这说明这次数据更新后 oldEndVnode 到了 oldStartVnode <u>前面</u>了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的<u>前面</u>，同时老 VNode 节点结束索引<u>减 1</u>，新 VNode 节点的开始索引<u>加 1</u>。</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用。这时候就找与newStartVnode 一致 <code>:key</code> 的旧的 VNode 节点，如果两者满足 sameVnode ，在进行 patchVnode 的同时会将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面；如果没有找到，就无法进行节点的复用，只能调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置。</li></ul><p>2）流程：</p><p>1、初始化：</p><img src="https://i.loli.net/2020/07/05/qKMmwChP9iHljBb.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>2、第一次循环：找到 旧节点末尾 和 新节点开头 (都是 D) 相同，复用 D 节点即可。同时旧节点的 endIndex 移动到了 C，新节点的 startIndex 移动到了 C。</p><img src="https://i.loli.net/2020/07/05/Yoc5FAqERtudwnI.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>3、第二次循环：同样是 旧节点末尾 和 新节点开头 (都是 C) 相同，于是创建 C 节点，插到D节点后。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E。（为什么第一次是复用，第二次是创建了？因为 old 序列队尾就是D直接复用即可）</p><img src="https://i.loli.net/2020/07/05/J2IpECfNtbUgmZL.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>4、第三次循环：发现 patchVnode 的 4 种情形都不符合，于是在旧节点队列中查找当前的新节点 E，不存在，只能创建新的节点 E，插入到 C 节点后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动。</p><img src="https://i.loli.net/2020/07/05/ROTXd9Fl5uM8bHj.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom: 50%;" /><p>5、第四次循环：新旧节点的开头 (都是 A) 相同，于是创建 A 节点，插入到 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的 startIndex 移动到了 B。</p><img src="https://i.loli.net/2020/07/05/T8b1y3QdwMEuCO6.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>6、第五次循环：同第四次循环，创建 B 节点插入到 A 节点后面。同时旧节点的 startIndex 移动到了 C，新节点的 startIndex 移动到了 F。这时候发现新节点的 startIndex 已经大于 endIndex 了。不再满足循环的条件了，因此结束循环。</p><img src="https://i.loli.net/2020/07/05/iFwarlM67Pf9vLA.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /><p>7、循环结束后，若 新节点数 大于 老节点数 则需要创建多出来的节点加入到队列中，反之删除。至此整个 diff 过程就已经全部完成了。在本例中，新节点数大于旧节点数，需要创建 newStartIdx 和 newEndIdx 之间的所有节点。在实例中就是 F 节点，因此创建 F 节点加入到 B 节点后即可。</p><img src="https://i.loli.net/2020/07/05/ouLQk1bpJKl7G8N.png" srcset="/img/loading.gif" alt="Vue的diff算法解析" style="zoom:50%;" /></li></ul><h3 id="4-参考-1"><a href="#4-参考-1" class="headerlink" title="4. 参考"></a>4. 参考</h3><p><a href="https://en.wikipedia.org/wiki/Diff" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Diff</a></p><p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></p><p><a href="https://www.zhihu.com/question/31809713" target="_blank" rel="noopener">https://www.zhihu.com/question/31809713</a></p><p><a href="https://www.zhihu.com/question/66851503" target="_blank" rel="noopener">https://www.zhihu.com/question/66851503</a></p><p><a href="https://juejin.im/post/5affd01551882542c83301da" target="_blank" rel="noopener">https://juejin.im/post/5affd01551882542c83301da</a></p><p><a href="https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f" target="_blank" rel="noopener">https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f</a></p><h2 id="三、感受"><a href="#三、感受" class="headerlink" title="三、感受"></a>三、感受</h2><p>diff算法算出来 O(n<sup>3</sup>) 真的看不懂，别人花了好几十年优化成 O(n<sup>3</sup>) ，待我水平够了再回看。这次重新复习 VDOM 让我对之前看Vue.js源码的理解有了更多更深的理解。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见Web攻击和防范</title>
    <link href="/2020/07/04/%E5%B8%B8%E8%A7%81Web%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E8%8C%83/"/>
    <url>/2020/07/04/%E5%B8%B8%E8%A7%81Web%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="常见Web攻击和防范"><a href="#常见Web攻击和防范" class="headerlink" title="常见Web攻击和防范"></a>常见Web攻击和防范</h1><h2 id="一、XSS-攻击和防范"><a href="#一、XSS-攻击和防范" class="headerlink" title="一、XSS 攻击和防范"></a>一、XSS 攻击和防范</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞注入恶意代码，在用户浏览器上运行，从而盗取用户的信息如 cookie 等。</p><h3 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h3><ul><li>存储型：恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</li><li>反射型：攻击者构建了特殊的 URL，当服务器接收到请求后，网站服务端将恶意代码从 URL 中取出，拼接到 HTML 后返回，浏览器接收后执行，从而导致了恶意代码的执行。</li><li>DOM 型：攻击者构建了特殊的 URL，用户打开带有恶意代码的 URL，浏览器接收到响应后解析执行，前端 JS 取出 URL 中的恶意代码并执行，从而导致了恶意代码的执行。</li></ul><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>DOM 型 XSS 跟前两种 XSS 的区别是：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="3-防范"><a href="#3-防范" class="headerlink" title="3. 防范"></a>3. 防范</h3><p>从上面的介绍可以知道预防 XSS 攻击有两个方面：恶意代码提交的时候 和 浏览器执行恶意代码的时候。</p><ol><li><p>前者：可分为两个过滤时机 前端过滤 和 后端过滤 </p><p>1）前端过滤：不可行，攻击者可绕过；</p><p>2）后端过滤：不可靠，当后端对存入数据库的数据都进行转义处理，再取出使用的时候，是不知道数据最后的使用场景的。</p></li><li><p>后者：可分为 纯前端渲染 和 对 HTML 做充分转义</p><p>1）纯前端渲染：回传的 HTML 不包含任何数据，数据通过 JS 请求得来，对 DOM 操作加载到页面上。但还需注意避免 DOM 型 XSS 漏洞。*</p><p>2）对 HTML 做充分转义：使用模板引擎，但不完善。</p><p>*DOM 型：网站前端 JavaScript 代码本身不够严谨，谨慎使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> ，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p></li></ol><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h3><ol><li><p>CSP ：通过指定有效域即只执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</p></li><li><p>使用js-xss库：<a href="http://jsxss.com" target="_blank" rel="noopener">http://jsxss.com</a></p></li><li><p>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</p></li><li><p>验证码：防止脚本冒充用户提交危险操作。</p></li><li><p>对于不受信任的输入，都应该限定一个合理的长度。</p></li></ol><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">https://juejin.im/post/5bad9140e51d450e935c6d64</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p><p><a href="https://allenxz.github.io/2019/11/17/safety" target="_blank" rel="noopener">https://allenxz.github.io/2019/11/17/safety</a></p><h2 id="二、XSRF-CSRF-攻击和防范"><a href="#二、XSRF-CSRF-攻击和防范" class="headerlink" title="二、XSRF/CSRF 攻击和防范"></a>二、XSRF/CSRF 攻击和防范</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>一个典型的CSRF攻击有着如下的流程：</p><ul><li><a href="http://xn--a-f38al5vkzdt61bv7l.com" target="_blank" rel="noopener">受害者登录a.com</a>，并保留了登录凭证（Cookie）。</li><li><a href="http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com" target="_blank" rel="noopener">攻击者引诱受害者访问了b.com</a>。</li><li><a href="http://b.com" target="_blank" rel="noopener">b.com</a> 向 <a href="http://a.com" target="_blank" rel="noopener">a.com</a> 发送了一个请求：<a href="http://a.com/act=xx。浏览器会默认携带a.com的Cookie。" target="_blank" rel="noopener">a.com/act=xx。浏览器会…</a></li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li></ul><h3 id="2-类型-1"><a href="#2-类型-1" class="headerlink" title="2. 类型"></a>2. 类型</h3><h3 id="3-防范-1"><a href="#3-防范-1" class="headerlink" title="3. 防范"></a>3. 防范</h3><p>从上面的介绍可以知道预防 CSRF 攻击有两个方面：阻止不明外域的访问 和 请求时附加特定信息。</p><ol><li><p>前者：</p><p>1）同源检测：在浏览器发起请求时，大多会自动带上Origin Header和Referer Header，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域；如果Origin和Referer都不存在，建议直接进行阻止。</p><p>2）Samesite Cookie属性：Set-Cookie的属性，分为 Strict 和 Lax。严格模式下Cookie 不可作为第三方 Cookie；宽松模式下假如有请求改变了当前页面或者打开新页面且同时是个GET请求，就可作为第三方 Cookie。</p></li></ol><pre><code class="hljs html">Set-Cookie: foo=1; Samesite=Strict Set-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3实例：假如淘宝网用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</code></pre><ol start="2"><li><p>后者：</p><p>1）CSRF Token：根据攻击者只会冒用Cookie的特征，服务器就要求所有用户请求时携带攻击者无法获取到的Token，由服务器随机生成。</p><p>2）双重Cookie认证：根据攻击者只会冒用Cookie的特征，服务器要求所有用户请求时携带一个Cookie中的值，这个值会在服务器随机生成，并在响应头给出。</p></li></ol><h3 id="4-补充-1"><a href="#4-补充-1" class="headerlink" title="4. 补充"></a>4. 补充</h3><ol><li>验证码、手机短信等都可以起到CSRF Token的作用，而且更安全。</li><li>使用CSRFTester。</li></ol><h3 id="5-参考-1"><a href="#5-参考-1" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener">https://juejin.im/post/5bc009996fb9a05d0a055192</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie</a></p><h2 id="三、感受"><a href="#三、感受" class="headerlink" title="三、感受"></a>三、感受</h2><p>看了很多资料，个人认为攻防方式只能互相对应，实际生产中会用各种各样的方式来保证信息安全，降低风险，但不可能完全消除风险。</p><p>更多的安全知识有待继续探究。</p><p><a href="https://www.v2ex.com/t/516357" target="_blank" rel="noopener">https://www.v2ex.com/t/516357</a></p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同源策略和跨域方案</title>
    <link href="/2020/07/04/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/04/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="同源策略和跨域方案"><a href="#同源策略和跨域方案" class="headerlink" title="同源策略和跨域方案"></a>同源策略和跨域方案</h1><h2 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/port" target="_blank" rel="noopener">port</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/host" target="_blank" rel="noopener">host</a> 都相同的话，则这两个 URL 是同源。</p><h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><img src="https://i.loli.net/2020/07/04/oF94YraAtjB8c3X.png" srcset="/img/loading.gif" alt="image-20200704114257308" style="zoom:80%;" /><h3 id="3、参考"><a href="#3、参考" class="headerlink" title="3、参考"></a>3、参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><h2 id="二、跨域方案"><a href="#二、跨域方案" class="headerlink" title="二、跨域方案"></a>二、跨域方案</h2><h3 id="1、JSONP"><a href="#1、JSONP" class="headerlink" title="1、JSONP"></a>1、JSONP</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">url, params, callback</span>) </span>&#123;  <span class="hljs-comment">// 判断是否含有参数</span>  <span class="hljs-keyword">let</span> queryString = url.indexOf(<span class="hljs-string">"?"</span>) === <span class="hljs-string">"-1"</span> ? <span class="hljs-string">"?"</span> : <span class="hljs-string">"&amp;"</span>;  <span class="hljs-comment">// 添加参数</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> params) &#123;    <span class="hljs-keyword">if</span> (params.hasOwnProperty(k)) &#123;      queryString += k + <span class="hljs-string">"="</span> + params[k] + <span class="hljs-string">"&amp;"</span>;    &#125;  &#125;  <span class="hljs-comment">// 处理回调函数名</span>  <span class="hljs-keyword">let</span> random = <span class="hljs-built_in">Math</span>.random()      .toString()      .replace(<span class="hljs-string">"."</span>, <span class="hljs-string">""</span>),    callbackName = <span class="hljs-string">"myJsonp"</span> + random;  <span class="hljs-comment">// 添加回调函数</span>  queryString += <span class="hljs-string">"callback="</span> + callbackName;  <span class="hljs-comment">// 构建请求</span>  <span class="hljs-keyword">let</span> scriptNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);  scriptNode.src = url + queryString;  <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 调用回调函数</span>    callback(...arguments);    <span class="hljs-comment">// 删除这个引入的脚本</span>    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].removeChild(scriptNode);  &#125;;  <span class="hljs-comment">// 发起请求</span>  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"head"</span>)[<span class="hljs-number">0</span>].appendChild(scriptNode);&#125;</code></pre><h3 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h3><ol><li><p>总概：在向服务器发送请求的时候，加上一些特定的头部信息，并配置服务器，让服务器放行该种请求，返回资源。</p></li><li><p>示例：</p><p>请求报文：</p></li></ol><pre><code class="hljs shell">Origin: http://foo.example</code></pre><p>​        响应报文：</p><pre><code class="hljs shell">Access-Control-Allow-Origin: *</code></pre><ol start="3"><li>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li></ol><h3 id="3、Vue-js中使用代理"><a href="#3、Vue-js中使用代理" class="headerlink" title="3、Vue.js中使用代理"></a>3、Vue.js中使用代理</h3><ol><li>实现：</li></ol><pre><code class="hljs js"><span class="hljs-comment">// vue.config.js</span>devServer: &#123;    proxy: &#123;  <span class="hljs-comment">//配置跨域</span>      <span class="hljs-string">'/api'</span>: &#123;        target: <span class="hljs-string">'http://121.121.67.254:8185/'</span>,  <span class="hljs-comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span>        changOrigin: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//允许跨域</span>        pathRewrite: &#123;          <span class="hljs-comment">/* 重写路径，当我们在浏览器中看到请求的地址为：</span><span class="hljs-comment">          http://localhost:8080/api/core/getData/userInfo 时，</span><span class="hljs-comment">          实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api */</span>          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span>         &#125;      &#125;,    &#125;  &#125;,</code></pre><ol start="2"><li>补充：这种方法只适合于开发阶段，工程尚未编译的时候使用，仅作为一个方便调用接口的解决方案。</li><li>参考：<a href="https://www.cnblogs.com/lihaohua/p/12372267.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihaohua/p/12372267.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用图床为md插入图片</title>
    <link href="/2020/07/04/%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%E4%B8%BAmd%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2020/07/04/%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A%E4%B8%BAmd%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用图床为md插入图片"><a href="#使用图床为md插入图片" class="headerlink" title="使用图床为md插入图片"></a>使用图床为md插入图片</h1><h2 id="一、背景原因"><a href="#一、背景原因" class="headerlink" title="一、背景原因"></a>一、背景原因</h2><p>在之前的那篇Hexo搭建的博文中提到使用<code>post_asset_folder: true</code>来处理md中的图片资源。虽然有考虑过在国内使用GitHub的体验很差，图片加载速度慢，但相比于图床的工作量，还是觉得图床使用不方便，但现在新发现了一个非常方便的方法。</p><h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><ol><li><p>下载并安装 Typora ：<a href="https://www.typora.io/#download" target="_blank" rel="noopener">https://www.typora.io/#download</a></p><p>暂时只知道 Typora 有该功能。</p></li><li><p>下载并安装 PicGo ：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p><p>最低使用 2.3.0 版本（ beta 版本亦可）</p></li><li><p>注册图床帐号：<a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p></li><li><p>在图床后台生成 token ：</p><p>sm.ms首页-&gt;User-&gt;Dashboard-&gt;API Token-&gt;Generate Secret Token-&gt;选中、右键、复制 Secret Token</p></li><li><p>为 PicGo 添加Token：</p><p>打开PicGo-&gt;左侧图床设置-&gt;SM.MS图床-&gt;粘贴刚刚复制的Token</p></li><li><p>连接 Typora 和 PicGo ：</p><p>打开Typora-&gt; 左上角”文件”-&gt;使用偏好-&gt;左侧图像-&gt;按照下方图片设置各个选项</p><img src="https://i.loli.net/2020/07/04/W5rX1PiQIEZKSlo.png" srcset="/img/loading.gif" alt="image-20200704111446575" style="zoom:67%;" /></li><li><p>完成：</p><p>按照这些步骤完成设置之后，就可以直接在Typora 里粘贴任何地方的图片了，然后Typora 会自动把图片上传到你的图床帐号上，并且自动插入图片。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面性能优化</title>
    <link href="/2020/07/03/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2020/07/03/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h1><h2 id="一、页面加载过程"><a href="#一、页面加载过程" class="headerlink" title="一、页面加载过程"></a>一、页面加载过程</h2><ul><li><p>加载</p><ol><li>DNS解析：域名 -&gt; IP地址；</li><li>取得目的主机 MAC 地址；</li><li>浏览器与目的IP地址建立TCP连接，发起Http请求；</li><li>服务器处理请求，返回资源。</li></ol></li><li><p>渲染</p><ol><li>根据 HTML文件构建 DOM Tree，根据 CSS 文件构建 CSSOM ；</li><li>根据 DOM Tree 和 CSSOM 构建Render Tree；</li><li>遇到 &lt;script&gt; 就加载并执行 JS 代码，否则会造成页面的渲染的阻塞；</li><li>Render Tree 渲染结束；</li><li>断开 TCP 连接。</li></ol></li></ul><h2 id="二、优化方向与方法"><a href="#二、优化方向与方法" class="headerlink" title="二、优化方向与方法"></a>二、优化方向与方法</h2><p>1、总体方向：</p><ul><li><p>加快加载速度：</p><p>压缩代码，减少体积；</p><p>减少请求数；</p><p>使用 CDN 加速；</p><p>使用 SSR （服务器端渲染）。</p></li><li><p>加快渲染速度：</p><p>CSS放在 head 标签内，JS放在 body 最后；*</p><p>尽早开始执行JS，用 DOMContentLoaded 触发；**</p><p>懒加载；</p><p>缓存 DOM 查询操作，将对 DOM 的操作合并，最后再操作改变 DOM； </p><p>节流（throttle）、防抖（debounce）。</p></li></ul><p>*  前者是为了防止渲染过程中Render Tree发生改变重新渲染；后者是为了让页面尽快呈现出来，减少用户等待时间；</p><p>**  window.onload：等页面全部资源加载完才会执行，包括视频、图片;</p><p>​      DOMContentLoaded： DOM渲染完成后就能执行，此时图片、视频等可能为加载完成4。</p><p>2、实现方法：</p><ol><li><p>SSR ： 可以使用 Nuxt.js 做 SSR</p></li><li><p>懒加载：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"img"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"preview.png"</span> <span class="hljs-attr">data-realsrc</span>=<span class="hljs-string">"abc.png"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'img'</span>)</span><span class="actionscript">  img.src = img1.getAttribute(<span class="hljs-string">'data-realsrc'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p>节流（throttle）：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数节流的实现;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;  <span class="hljs-keyword">var</span> preTime = <span class="hljs-built_in">Date</span>.now();  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>,      args = <span class="hljs-built_in">arguments</span>,      nowTime = <span class="hljs-built_in">Date</span>.now();    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;      preTime = <span class="hljs-built_in">Date</span>.now();      <span class="hljs-keyword">return</span> fn.apply(context, args);    &#125;  &#125;;&#125;<span class="hljs-comment">// 业务实例：拖拽一个元素，要随时拿到该元素被拖拽的位置。</span><span class="hljs-comment">// 直接用drag事件，则会频发的触发，很容易导致卡顿。</span><span class="hljs-comment">// 而节流则是无论比拖拽多快，都会每隔一个固定事件触发一次。</span><span class="hljs-keyword">const</span> div1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'div1'</span>)div1.addEventListener(<span class="hljs-string">'drag'</span>, throttle( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(e.offsetX, e.offsetY)&#125;, <span class="hljs-number">200</span>))</code></pre></li><li><p>防抖（debounce）：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数防抖的实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>,      args = <span class="hljs-built_in">arguments</span>;    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span>    <span class="hljs-keyword">if</span> (timer) &#123;      clearTimeout(timer);      timer = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span>    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      fn.apply(context, args);    &#125;, wait);  &#125;;&#125;<span class="hljs-comment">// 业务实例：监听一个输入框的文字变化后，触发change事件。</span><span class="hljs-comment">// 直接用keyup事件，会频繁的触发change事件。</span><span class="hljs-comment">// 而防抖则是用户输入结束或者暂停时，才会触发change事件。</span><span class="hljs-keyword">const</span> input1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'input1'</span>)input1.addEventListener(<span class="hljs-string">'keyup'</span>, debounce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(input1.value)&#125;))</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建</title>
    <link href="/2020/07/03/Hexo%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/07/03/Hexo%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><ol><li><p>安装Node.js</p></li><li><p>换源</p><p><a href="https://www.jianshu.com/p/4aaf929bfa71" target="_blank" rel="noopener">https://www.jianshu.com/p/4aaf929bfa71</a></p><p>1）方法一：npm i -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>2）方法二：npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></li><li><p>安装hexo</p><p>npm i -g hexo-cli</p></li><li><p>在任意位置创建一个空目录来存放所有有关博客的东西</p><p>~/blog</p></li><li><p>初始化博客</p><p>hexo init</p></li><li><p>启动博客</p><p>hexo s</p></li></ol><h2 id="二、生成一篇博文"><a href="#二、生成一篇博文" class="headerlink" title="二、生成一篇博文"></a>二、生成一篇博文</h2><ol><li><p>生成一篇博文</p><p>hexo new post &lt;title&gt;</p></li><li><p>清理缓存</p><p>hexo clean</p></li><li><p>重新生成静态文件</p><p>hexo g</p></li><li><p>重新启动查看新建的博文（非必须）</p><p>hexo s</p></li></ol><h2 id="三、部署到GitHub上"><a href="#三、部署到GitHub上" class="headerlink" title="三、部署到GitHub上"></a>三、部署到GitHub上</h2><ol><li><p>创建一个新的仓库</p><p>仓库名：[username].github.io</p><p>ps. 仓库名必须为[username].github.io</p></li><li><p>在blog目录下安装git部署插件</p><p>目录：~/blog</p><p>命令：npm i -S hexo-deployer-git</p></li><li><p>配置 _config.yml</p><p>目录：~/blog</p><p>更改后：</p><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/lyanmm/lyanmm.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></li><li><p>部署到远端</p><p>hexo d</p></li><li><p>查看</p><p>https://[username].github.io/</p></li></ol><h2 id="四、后续发表的博文"><a href="#四、后续发表的博文" class="headerlink" title="四、后续发表的博文"></a>四、后续发表的博文</h2><ol><li><p>生成一篇博文</p><p>hexo new post &lt;title&gt;</p></li><li><p>清理缓存</p><p>hexo clean</p></li><li><p>重新生成静态文件</p><p>hexo g</p></li><li><p>部署到远端</p><p>hexo d</p></li></ol><h2 id="五、其他配置"><a href="#五、其他配置" class="headerlink" title="五、其他配置"></a>五、其他配置</h2><h3 id="1、更换主题"><a href="#1、更换主题" class="headerlink" title="1、更换主题"></a>1、更换主题</h3><p>可在GitHub上搜索主题</p><p>关键词：  hexo-theme-</p><h3 id="2、为md引入静态资源"><a href="#2、为md引入静态资源" class="headerlink" title="2、为md引入静态资源"></a>2、为md引入静态资源</h3><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders</a></p><h3 id="3、处理md中的图片资源"><a href="#3、处理md中的图片资源" class="headerlink" title="3、处理md中的图片资源"></a>3、处理md中的图片资源</h3><p>在网上搜寻一番都没有找到合适的方法，如果用图床则工作量太大，要逐个上传，后来自己慢慢摸索下发现这个方法可用。</p><ol><li><p>在 _config.yml 中修改：</p><p>post_asset_folder: true</p></li><li><p>引用：</p><p>new一篇博文后会生成一个 &lt;title&gt; 文件夹和 &lt;title&gt; .md 文件</p><p>将图片放入 &lt;title&gt; 文件夹中，</p><p>在md中直接插入img链接：&lt;img src=”[finename]” alt=”” style=”” /&gt;。</p></li></ol><p>这样的好处是可以通过修改img的style来调整大小，但也有一个缺点，就是md在本地是看不到图片的。</p><p>解决方法：在另外的地方正常写好md，全选复制到 new 出来的 md 中，然后将img标签 src 里前面一串路径删去留下文件名即可。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    
    <categories>
      
      <category>Application</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>碎语</title>
    <link href="/2020/07/02/%E7%A2%8E%E8%AF%AD/"/>
    <url>/2020/07/02/%E7%A2%8E%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="博客的由来"><a href="#博客的由来" class="headerlink" title="博客的由来"></a>博客的由来</h1><p>其实早就想写一个博客来记录平时的笔记等等，但是一直没有那个让我动手的、一瞬间的冲动。直到今晚，我在看一个视频的时候，UP主提到了写博客的事情，他之前也录了很多期搭博客的视频。上周还没考完期末考的时候我就在想，考完期末之后如果找不到实习，那就抽点时间出来写一下吧。这两天考完试也是尝试着投了几家，但暂时都没有回应。刚好晚上也比较困，不想继续复习了，于是就动手了。</p><h1 id="搭建感受"><a href="#搭建感受" class="headerlink" title="搭建感受"></a>搭建感受</h1><p>具体的搭建过程我已经写了另外的一篇，这里简单谈谈搭的时候的感受吧。我开始以为自己搭一个会很难，但其实都有现成的框架、主题、插件等等，整个过程还是挺顺利的，没有想象中的难。我本来下了很多主题想折腾一番的哈哈，最后还是只选了一个Material Design的主题。我个人还是挺喜欢Material Design，虽然现在谷歌好像很少提及了。但它当时出现的时候，我一眼就喜欢上这种风格了，鲜明有特色。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为最早开始学前端的时候，并没有想过把学习笔记放到博客上，所以都是用的Word记录，当时也不知道有Markdown这种文件格式，所以就没办法把早期的资料发布了。后来会用 md 了，记录的一些笔记，格式也没有调好，很多在本地看是正常的，但是发布之后格式就乱了。没办法，只能从现在开始注意好格式，把笔记写漂亮点。</p>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器存储方式</title>
    <link href="/2020/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/06/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h1><h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><p>通过 document.cookie = ‘….’ 操作。</p><p>cookie的缺点：</p><ul><li>有大小限制，最大4KB</li><li>http请求时需要发送到服务端，增加请求数据量</li></ul><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a></p><h2 id="二、Web-Storage-API"><a href="#二、Web-Storage-API" class="headerlink" title="二、Web Storage API"></a>二、Web Storage API</h2><p>Web Storage 包含如下两种机制：</p><ul><li><p>sessionStorage： 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</p></li><li><p>localStorage： 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。</p></li></ul><pre><code class="hljs js"><span class="hljs-comment">// 保存数据</span>sessionStorage.setItem(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);localStorage.setItem(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);<span class="hljs-comment">// 获取数据</span><span class="hljs-keyword">let</span> sData = sessionStorage.getItem(<span class="hljs-string">'key'</span>);<span class="hljs-keyword">let</span> lData = localStorage.getItem(<span class="hljs-string">'key'</span>);<span class="hljs-comment">// 删除保存的数据</span>sessionStorage.removeItem(<span class="hljs-string">'key'</span>);localStorage.removeItem(<span class="hljs-string">'key'</span>);<span class="hljs-comment">// 删除所有保存的数据</span>sessionStorage.clear();localStorage.clear();</code></pre><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码笔记</title>
    <link href="/2020/04/29/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/04/29/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="vue源码笔记"><a href="#vue源码笔记" class="headerlink" title="vue源码笔记"></a>vue源码笔记</h1><p>以下所有路径的 * = node_modules/vue</p><h2 id="零、生命周期图"><a href="#零、生命周期图" class="headerlink" title="零、生命周期图"></a>零、生命周期图</h2><img src="image-20200429093329909.png" srcset="/img/loading.gif" alt="image-20200429093329909" style="zoom:33%;" /><h2 id="一、初步认识Vue"><a href="#一、初步认识Vue" class="headerlink" title="一、初步认识Vue"></a>一、初步认识Vue</h2><h3 id="1、vue的编写规范"><a href="#1、vue的编写规范" class="headerlink" title="1、vue的编写规范"></a>1、vue的编写规范</h3><p>主要是用Flow，还有ts</p><h3 id="2、源码目录"><a href="#2、源码目录" class="headerlink" title="2、源码目录"></a>2、源码目录</h3><p>src</p><p>├ compiler        #编译相关</p><p>├ core                #核心代码</p><p>├ platforms       #不同平台的支持（web，weex）</p><p>├ server             #服务器渲染</p><p>├ sfc                    #对.vue文件的解析</p><p>├ shared             #公用部分，存放一些静态变量名，工具类</p><h3 id="3、源码构建"><a href="#3、源码构建" class="headerlink" title="3、源码构建"></a>3、源码构建</h3><p>基于Rollup，构建相关配置在package.json的scripts下，run不同的语句会编译出不同的vue版本。</p><h3 id="4、vue入口"><a href="#4、vue入口" class="headerlink" title="4、vue入口"></a>4、vue入口</h3><p>最上层的Vue类在*/src/core/instance/index.js。在这里会Mixin（混入）各种各样的模块，完成Vue的初始化。</p><h2 id="二、数据驱动"><a href="#二、数据驱动" class="headerlink" title="二、数据驱动"></a>二、数据驱动</h2><p>Vue.js一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作DOM，而是通过修改数据。它相比我们传统的前端开发，如使用jQuery等前端库直接修改DOM,大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为DOM变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触DOM，这样的代码非常利于维护。</p><h3 id="1、new-Vue发生了什么"><a href="#1、new-Vue发生了什么" class="headerlink" title="1、new Vue发生了什么"></a>1、new Vue发生了什么</h3><p>执行了*/src/core/instance/index.js 中的构造函数，并且进入到this._init(options)中（_init在*/src/core/instance/init.js中），会经历一系列的初始化，判断是否有重名，然后将数据、方法、props等挂载到vm上</p><h3 id="2、实例挂载实现了什么"><a href="#2、实例挂载实现了什么" class="headerlink" title="2、实例挂载实现了什么"></a>2、实例挂载实现了什么</h3><p>Vue中我们是通过$mount实例方法去挂载vm的，$mount 方法在多个文件中都有定义，如*/src/platform/web/ entry- runtime-with-compiler.js、*/src/platform/web/ runtime/ index.js、*/src/platform/weex/ runtime/index. js。因为$mount这个方法的实现是和平台、构建方式都相关的。</p><p>$mount在index.js &gt; initMixin(init.js中定义) &gt; Vue.prototype._init = function{……  if (vm.$options.el) {vm.$mount(vm.$options.el) }  }这里执行。（前面（即…处）执行了beforeCreate、created两个钩子，即生命周期的顺序。）</p><p>$mount是在entry-runtime-with-compiler.js（在带compiler的 版本中）中定义的。首先会把template（有多种方式获取）编译了，拿到render函数，然后再执行在Vue原型上的$mount。在Vue原型上的$mount上是有mountComponent的（在runtime-only版本中的index.js），mountComponent（在lifecycle.js中）调用beforeMount钩子，然后就是new Watcher() （在这new出来的是个渲染watcher），然后就mounted钩子了。</p><p>mountComponent函数在之后的更新视图中也会用到。</p><img src="image-20200502110200269.png" srcset="/img/loading.gif" alt="image-20200502110200269" style="zoom:50%;" /><img src="image-20200502110433648.png" srcset="/img/loading.gif" alt="image-20200502110433648" style="zoom:65%;" /><img src="image-20200429115053781.png" srcset="/img/loading.gif" alt="image-20200429115053781" style="zoom: 67%;" /><img src="image-20200429115623036.png" srcset="/img/loading.gif" alt="image-20200429115623036" style="zoom:67%;" /><p>总结：Vue实例里总会有一个render函数，如果定义的时候没有render函数，就会在执行过程中编译出一个render函数。在cli中，会有选择runtime-with-compiler/runtime-only，这个的意思就是，如果你选择runtime-with-compiler版本，就默认不认为你在定义的时候传入一个render函数，而是通过template、el、component等编译出render函数，然后再执行runtime（也即runtime-only）里的内容。选择runtime-only就意味着你在定义的时候就要传入一个render函数了，然后再设置挂载到哪个dom上。挂载过程：runtime-only.js内的$mount(){mountComponent}-&gt;mountComponent在lifecycle.js内有导出，在挂载的过程中，会new Watcher（没有执行），最后才挂载完成（即调用mounted钩子）。</p><p>new的这个Watcher就会实时观察到data的变化，虚拟DOM会重新渲染并应用更新（但其实这个过程中并不会再有mounted调用）（就如代码中，updateComponent执行了_update函数，_update函数执行了渲染函数）</p><img src="image-20200502121121603.png" srcset="/img/loading.gif" alt="image-20200502121121603" style="zoom:70%;" /><p>Watcher类在 */src/core/observer/watcher.js，watcher与响应式关系很强，之后更详细讲解。</p><p>ps.在mountComponent过程中，new的这个渲染watcher第二个参数传入的是updateComponent函数，new，然后进入到Watcher类内部，最后会执行this.get()，get函数是在Watcher类内部的，get函数内有this.getter = expOrFn（也即this.getter = updateComponent），该函数内部会以call的方式执行getter/updateComponent，并传入一个vm，但是这里的updateComponent是不接收任何参数的，所以猜测除了渲染watcher之外还有其他类型watcher，这里即使传入了vm给updateComponent也不做任何处理，仅updateComponent内部执行_update，_update内部执行_render，_render会返回一个vnode到_update（render细节见后文），然后这时才进入到_update函数体内，内部就会执行更新视图。这里传入的参数估计是为了其他类型watcher所设计。</p><img src="image-20200502163410108.png" srcset="/img/loading.gif" alt="image-20200502163410108" style="zoom:50%;" /><h3 id="3、render"><a href="#3、render" class="headerlink" title="3、render"></a>3、render</h3><p>路径：*/src/core/instance/render.js</p><p>Vue.prototype._render首先会取得vm.$options里的render函数（上面说过了render函数一般怎么生成的），然后以  vnode = render.call(vm._renderProxy, vm.$createElement)  的方式创建一个vnode，其中vm._renderProxy在init的时候已经创建好了，如果是在生产环境下就是vm本身。$createElement在render.js中initRender的（initRender在init.js里，初始化的时候就有执行了）开头有两种定义，第一种是用于编译出来的render函数，第二种是用户提供的render函数。实际上render拿到的返回值就是createElement的返回值。</p><p><img src="image-20200505112508410.png" srcset="/img/loading.gif" alt="image-20200505112508410" style="zoom: 67%;" /><img src="image-20200505112602051.png" srcset="/img/loading.gif" alt="image-20200505112602051" style="zoom:67%;" /></p><h3 id="4、Virtual-DOM"><a href="#4、Virtual-DOM" class="headerlink" title="4、Virtual DOM"></a>4、Virtual DOM</h3><p>Virtual DOM就是用一个原生的JS对象去描述一个DOM节点，所以它比创建一个DOM的代价要小很多。在Vue.js中，Virtual DOM是用VNode Class去描述，它是定义在src/core/vdom/vnode.js中的。</p><p>其中  data: VNodeData | void;  这个属性，期待的 VNodeData 类型在  */types/vnode.d.ts  中有定义。</p><p>其实Vue.js中的Virtual DOM是基于一个叫snabbdom的开源库实现的。</p><p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom</a></p><p>总结：其实VNode是对真实DOM的一种抽象描述，它的核心定义就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展VNode的灵活性以及实现一些特殊 feature的。由于VNode只是用来映射到真实DOM的渲染，不需要包含操作DOM的方法，因此它是非常轻量和简单的。Virtual DOM除了它的数据结构的定义，映射到真实的DOM实际上要经历VNode的create、diff、patch 等过程。在Vue.js中，VNode的create是通过之前提到的createElement 方法创建的，实现方式见下文。</p><h3 id="5、createElement"><a href="#5、createElement" class="headerlink" title="5、createElement(*)"></a>5、createElement(*)</h3><p>路径：*/src/core/vdom/create-element.js</p><p>官方参数：</p><img src="image-20200508175815655.png" srcset="/img/loading.gif" alt="image-20200508175815655" style="zoom: 67%;" /><p>主要思路：</p><p>createElement 方法内部会先判断data的类型，因为传参的时候data是可以为空，然后就把后面的参数向后移位</p><img src="image-20200508112333309.png" srcset="/img/loading.gif" alt="image-20200508112333309" style="zoom:67%;" /><p>最后才是调用_createElement(context, tag, data, children, normalizationType)（返回一个VNode）：</p><img src="image-20200508112702352.png" srcset="/img/loading.gif" alt="image-20200508112702352" style="zoom: 67%;" /><p>1）判断传进来的data不能是响应式的，然后判断data.is(**)，如果有这个属性，就会进行相关的处理。（注意，在标签内使用v-bind:is，data.is也是undefined！因为这两个不是一样的东西！）。</p><p>2）判断“normalizationType === ALWAYS_NORMALIZE”，因为当我们手写render函数的时候，经常children那一项（即第二/三项）是传一个任意的数据，但是_createElement内部运行的时候，children要是一维的Array&lt;Node&gt;，所以就要对传入的这个任意类型数据进行格式化，其中有两种格式化方式：simpleNormalizeChildren和normalizeChildren。前者是编译生成的render才用的简单格式化方式，后者是手写render用的，可以完全保证格式化后children是个数组（ps.在simpleNormalizeChildren过程中，有种结果是会调用normalizeArrayChildren，在这个函数里有对文本VNode进行性能优化，如果前后两个VNode都是文本，就会合并这两个VNode为一个）。</p><img src="image-20200508181927801.png" srcset="/img/loading.gif" alt="image-20200508181927801" style="zoom:67%;" /><p>3）      如果tag是标签（字符串类型）：</p><p>​                        如果tag为HTML原生标签：</p><p>​                                            就创建一个原生标签VNode；</p><p>​                         如果(!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, ‘components’, tag))为</p><p>​                                            真：就创建一个组件VNode；</p><p>​                         啥都不是，就按照给定的数据创建一个特殊的VNode；</p><p>​              否则创建组件VNode；</p><img src="image-20200508224956330.png" srcset="/img/loading.gif" alt="image-20200508224956330" style="zoom:33%;" /><p>关于createComponent后面讲。</p><p>4）最后就是一系列的判断和在VNode上对:class,:style的深度绑定，最后的最后_createElement返回一个VNode </p><p>*<a href="https://cn.vuejs.org/v2/guide/render-function.html#createElement-参数" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/render-function.html#createElement-%E5%8F%82%E6%95%B0</a>，</p><p><a href="https://stackoverflow.com/questions/61675846/a-question-about-vue-js-source-code-in-function-createelement" target="_blank" rel="noopener">https://stackoverflow.com/questions/61675846/a-question-about-vue-js-source-code-in-function-createelement</a></p><p>**这是一个有关动态组件的属性，data对象是与模板中 attribute 对应的数据对象，参考<a href="https://cn.vuejs.org/v2/guide/render-function.html#深入数据对象" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1</a>，<a href="https://cn.vuejs.org/v2/guide/components.html#动态组件" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6</a></p><h3 id="6、update"><a href="#6、update" class="headerlink" title="6、update"></a>6、update</h3><p>路径：*/src/core/instance/lifecycle.js</p><p>Vue的_update是实例的一个私有方法，它被调用的时机有2个，首次渲染和数据更新。这里先只分析首次渲染，数据更新在之后关于响应式原理的时候写。_update方法的作用是把VNode渲染成真实的DOM。</p><img src="image-20200511092044826.png" srcset="/img/loading.gif" alt="image-20200511092044826" style="zoom:67%;" /><p>在该函数中首先会判断vue实例中是否已经存在Vnode（vm._vnode），因为update有两个触发时机，首次渲染和数据更新，如果不存在Vnode即为首次渲染，会执行__patch__函数，该函数在定义到Vue原型上之前会先判断</p><pre><code class="hljs ini"><span class="hljs-attr">Vue.prototype.__patch__</span> = inBrowser ? patch : noop<span class="hljs-comment">;</span></code></pre><p>即判断是否为浏览器环境（Vue也可以在weex中，这里只讨论浏览器），patch函数在  */src/platforms/web/runtime/patch.js  中定义，由createPatchFunction赋值得到，createPatchFunction在  */src/core/vdom/patch.js  中有导出。</p><img src="image-20200511153831668.png" srcset="/img/loading.gif" alt="image-20200511153831668" style="zoom:67%;" /><p>createPatchFunction的参数：nodeOps是一些对DOM的操作；modules是生成标签时的一些类、属性的钩子函数，在patch过程中会调用。（snabbdom的逻辑就是，当创建一个VNode时，调用一些相关的钩子函数以生成类、属性等，每个钩子函数对应一个module对应标签内的类/属性等）。</p><p>而createPatchFunction在*/src/core/vdom/patch.js中定义，在这个函数中会把所有的hooks和modules对应起来，以达到上面说的snabbdom的逻辑，并且还定义大量的辅助函数，只为最终返回的patch函数，这个函数就是上面提到的patch函数。</p><img src="image-20200511152314321.png" srcset="/img/loading.gif" alt="image-20200511152314321" style="zoom:80%;" /><p>为什么定义一个patch函数要绕一大圈，要经过createPatchFunction来创建：因为Vue.js可多平台运行的，为解决兼容多平台而可能造成的代码冗余，用了一种叫函数柯里化(***)的方法巧妙解决了，createPatchFunction顾名思义就是创建patch函数，在  */src/platforms/web/runtime/patch.js  中会生成对应平台（这里指web）所用到的modules，并传入createPatchFunction，这样在其他平台的使用的时候，也只需要生成其他平台所用到的modules传进createPatchFunction即可。</p><hr><img src="image-20200511160409935.png" srcset="/img/loading.gif" alt="image-20200511160409935" style="zoom:67%;" /><p>在patch中，先判断了oldVnode, vnode（分别对应于vm.$el,vnode，这里的vnode是由渲染函数创建出来的，上几节有讲）是否都有定义了，然后判断oldVnode是否为真实DOM，这里讨论首次渲染和浏览器环境的情况，所以必然为true，最后就用一个空的VNode来替代掉。</p><img src="image-20200511162205485.png" srcset="/img/loading.gif" alt="image-20200511162205485" style="zoom:67%;" /><p>这时oldVnode就真的是个VNode了，接下来要做的事情就是把vnode替换掉原来的oldVnode，即把vnode转换为真实的DOM：首先执行了createElm，该函数体内有</p><pre><code class="hljs reasonml">vnode.elm = vnode.ns  ? nodeOps.create<span class="hljs-constructor">ElementNS(<span class="hljs-params">vnode</span>.<span class="hljs-params">ns</span>, <span class="hljs-params">tag</span>)</span>  : nodeOps.create<span class="hljs-constructor">Element(<span class="hljs-params">tag</span>, <span class="hljs-params">vnode</span>)</span>set<span class="hljs-constructor">Scope(<span class="hljs-params">vnode</span>)</span>node_modules/vue/src/platforms/web/runtime/node-ops.js</code></pre><p>这里就是真正的调用原生API来创建DOM了，然后还会判断是否有子节点，如果有又会调用createChildren，createChildren又会递归调用createElm，确保所有子节点都能被创建，最后让子节点insert到父节点里面。（在insert函数内会对原生DOM进行操作）至此走完了createElm。</p><img src="image-20200511165922722.png" srcset="/img/loading.gif" alt="image-20200511165922722" style="zoom:67%;" /><p>回到patch中，因为是首次渲染，所以不需要递归的更新父占位节点元素，然后销毁旧的节点（在首次渲染中就是那个用于提供位点的&lt;div id=”app”&gt;&lt;/div&gt;），最后返回vnode.elm。</p><p>ps.hydrate：服务端渲染是相对于客户端渲染而言的(Client Side Render), 它的渲染行为发生在服务器端, 渲染完成之后再将完整页面以HTML字符串的形式交给浏览器, 最后经过”注水” hydrate 过程将一些事件绑定和Vue状态等注入到输出的静态的页面中, 由同步下发给浏览器的的Vue bundle接管状态, 继续处理接下来的交互逻辑。</p><p>***<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a></p><p>粗略的流程：</p><img src="image-20200511214625063.png" srcset="/img/loading.gif" alt="image-20200511214625063" style="zoom:70%;" /><h2 id="三、组件化"><a href="#三、组件化" class="headerlink" title="三、组件化"></a>三、组件化</h2><p>接下来的讲解均为使用vue-cli生成的模板，自带render。</p><h3 id="1、createComponent"><a href="#1、createComponent" class="headerlink" title="1、createComponent"></a>1、createComponent</h3><p>路径：*/src/core/vdom/create-component.js</p><img src="image-20200511212836159.png" srcset="/img/loading.gif" alt="image-20200511212836159" style="zoom:67%;" /><p>在执行到_createElement的时候，里面就走的是else里的代码了，执行createComponent，本质都是生成一个VNode。</p><p>待续…</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
